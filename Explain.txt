1. Explain
A. Wrong - ElastiCache is a caching layer, primarily for reads. It doesn't directly improve the performance of S3 PUT (write) operations. S3 performance is managed by S3 itself.
B. Wrong - ElastiCache is for caching data and session management; it has no direct function in improving the latency or speed of AWS CodeDeploy deployments.
C. Correct - ElastiCache is an in-memory caching service, which provides sub-millisecond latency and significantly higher throughput compared to disk-based databases, making it excellent for read-heavy workloads.
D. Wrong - ElastiCache is a caching service. It has no relationship with speeding up branch merges in a source control system like AWS CodeCommit.
E. Correct - Caching the results of compute-intensive operations (like complex calculations or database aggregations) in ElastiCache prevents the application from having to recalculate or re-query the database repeatedly, thus improving overall application performance.

2. Explain
A. Correct - Amazon ElastiCache (using Redis or Memcached engines) is fundamentally a fast, in-memory key/value store.
B. Wrong - Simple Notification Service (SNS) is a fully managed messaging service for application-to-application (A2A) and application-to-person (A2P) communication, not a key/value store.
C. Correct - Amazon DynamoDB is a NoSQL database that is primarily a highly scalable, fully managed key/value store and document database.
D. Wrong - Simple Workflow Service (SWF) is a service for coordinating work across distributed application components, not a key/value store.
E. Correct - Simple Storage Service (S3) is an object storage service where each object is stored and retrieved using a unique object key, making it a form of key/value store for objects.

3. Explain
A. Wrong - While the Lambda function and target group must be properly configured, placing them in the same account is often a prerequisite for configuration but not the specific action needed to enable multi-value header transfer.
B. Wrong - The request body size limit is a general constraint for the Lambda payload, not the specific setting for enabling multi-value headers.
C. Wrong - Including the Base64 encoding status, status code, etc., is related to how the Lambda function formats its response back to the ALB (payload format), not how the ALB handles incoming multi-value headers in the request.
D. Correct - For an Application Load Balancer to pass multi-value headers (where a header name has multiple comma-separated values) to a Lambda target, the multi-value headers feature must be explicitly enabled on the ALB target group configuration.

4. Explain
A. Wrong - Write-Back or Write to Cache Directly: This policy updates the cache first and syncs to the backend later. This can lead to data loss and weak consistency since the database and cache will temporarily have different values.
B. Wrong - Write to Backend and Wait for Cache to Expire: This is the Cache-Aside strategy with no proactive invalidation. This causes a stale data window (weak consistency) until the item's Time-To-Live (TTL) expires, which violates the strong consistency requirement.
C. Wrong - Write to the Cache and the Backend at the same time: This is the Write-Through strategy. While this ensures consistency, if the cache update fails but the backend update succeeds, or vice-versa, it can still lead to inconsistency.
D. Correct - The requirement for strong consistency dictates that the database (backend) must be updated before the cache. The Write-Through/Write-Around with Cache Invalidation strategy ensures the backend is updated first, and then the corresponding item in the cache is immediately invalidated/deleted.

5. Explain
A. Wrong - While VPN tunnels provide an encrypted channel, the most common and standard mechanism for S3 protection *in transit* is SSL/TLS. This option also requires extra setup (VPC, VPN, Endpoint) when a simple HTTPS request is sufficient.
B. Correct - When using Client-Side Encryption, the data is encrypted on the client machine before it is sent to S3. Since the data is already encrypted when it leaves the client, the data is protected in transit and at rest.
C. Wrong - Server-Side Encryption (SSE-KMS) protects data at rest (while stored in S3) by encrypting it *after* it reaches the S3 server. It does not directly encrypt the data while it is being transferred to S3.
D. Correct - Encrypting data in transit means securing the connection between the client and S3. Using an SSL/TLS (HTTPS) connection is the standard way to encrypt data while it's being transferred over the internet.
E. Wrong - Server-Side Encryption (SSE-S3) protects data at rest (while stored in S3) by encrypting it *after* it reaches the S3 server. It does not directly encrypt the data while it is being transferred to S3.

6. Explain
A. Wrong - SSE-S3 does not provide an audit trail in CloudTrail for key usage because the key is managed entirely by S3.
B. Correct - Server-side encryption with AWS KMS-managed keys (SSE-KMS) meets both requirements: it provides an audit trail via CloudTrail for key usage and, as a Server-Side Encryption method, it minimizes performance impact on the client/application.
C. Wrong - Client-side encryption adds a performance overhead to the application because the application itself must perform the encryption/decryption on the client side.
D. Wrong - Client-side encryption with AWS KMS still requires the client to perform the encryption/decryption, thus impacting application performance.

7. Explain
A. Correct - The cross-account IAM role is the standard, most secure, and most recommended pattern for cross-account access in AWS. The application in Account A assumes a specific role in Accounts B and C which has a defined, least-privilege set of permissions. This avoids sharing long-lived credentials.
B. Wrong - S3 cross-region replication is for data redundancy, not for general service access or security auditing across accounts.
C. Wrong - Deploying an application in each audited account just to handle authentication for Account A is overly complex and unnecessary.
D. Wrong - Creating an IAM user with an access key in each audited account is less secure because it involves distributing and managing long-lived credentials (access keys) instead of relying on temporary session tokens from assumed roles.

8. Explain
A. Wrong - AWS CodeDeploy cannot directly access local on-premises storage to retrieve the bundle. It requires the bundle to be stored in an accessible location like S3.
B. Correct - AWS CodeDeploy can pull application revisions from Amazon S3. Since the company bundles the application on-premises, the correct process is to upload the bundle (e.g., zip or tar.gz file) to an Amazon S3 bucket and then specify that S3 location when initiating a deployment using CodeDeploy.
C. Wrong - AWS CodeCommit is a source control service, not a deployment service.
D. Wrong - AWS CodeBuild is a building and compiling service, not a deployment service. CodeDeploy is the service designed for deployment to EC2.

9. Explain
A. Correct - Using encrypted Amazon EBS volumes is the most transparent and high-performance way to encrypt block storage on EC2. The encryption/decryption is handled by the AWS hypervisor layer, offloading the work from the EC2 instance's CPU and minimizing performance impact.
B. Wrong - Writing to S3 would require a complete application redesign and is not an alternative for local block storage.
C. Wrong - Adding a custom encryption algorithm to the application would place a significant computational burden on the application's CPU, thus impacting performance.
D. Wrong - Ephemeral disks (Instance Store) are not persistent; the data is lost when the instance is stopped or terminated, which is not suitable for most application data.

10. Explain
A. Wrong - Creating multiple S3 prefixes helps with S3 request rate scaling but does not address the issue of high-latency global access, which is the root cause of performance degradation for global users.
B. Wrong - ElastiCache is typically used for application data (like database query results or sessions) and is not the ideal, purpose-built solution for caching static/public content like images globally. CloudFront is superior for this use case.
C. Correct - Amazon CloudFront is a Content Delivery Network (CDN) that caches content, like image files, at Edge Locations around the world. This results in significantly lower latency and reduced load/traffic on the origin.
D. Wrong - S3 request limits are generally very high. The problem is usually latency for global users, not S3's ability to handle the rate.

11. Explain
A. Wrong - The developer cannot use the default or a custom KMS Customer Master Key (CMK) directly to encrypt a large file (like 3MB) because CMKs have a small data size limit (4KB).
B. Wrong - The S3 managed key (SSE-S3) is for Server-Side Encryption, which happens *after* the file is uploaded. The requirement is to encrypt the data before uploading.
C. Correct - For Client-Side Encryption using AWS KMS, the developer must use the GenerateDataKey API to obtain a plaintext key, use that key to encrypt the 3MB JSON file inside the Lambda function code, and then upload the encrypted data.
D. Wrong - The developer cannot use the default or a custom KMS Customer Master Key (CMK) directly to encrypt a large file (like 3MB) because CMKs have a small data size limit (4KB).

12. Explain
A. Wrong - Versioning is for data recovery and protection, not related to fixing browser Same-Origin Policy issues.
B. Wrong - A bucket policy can allow public access, but the *browser* will still block the cross-origin request unless a CORS configuration is in place.
C. Wrong - The Content-MD5 header is an integrity check, not related to fixing cross-origin request issues.
D. Correct - Browsers enforce the Same-Origin Policy. The request is blocked because the resource is on a different origin (S3 bucket). Configuring Cross-Origin Resource Sharing (CORS) on the cdfonts S3 bucket explicitly allows the website's domain to access its contents.

13. Explain
A. Wrong - sam init is used only once to create a new SAM project, not to redeploy an existing one.
B. Wrong - sam validate checks the syntax of the template.yaml file; it is a useful check but not required for deployment.
C. Correct - sam build compiles and packages the source code, creating a deployment artifact that is structured for AWS Lambda. This step is necessary to prepare the changes for deployment.
D. Correct - sam deploy takes the build artifacts, uploads them to S3, and then uses AWS CloudFormation to update the deployed stack with the new code and template changes. This is the command that performs the actual redeployment.
E. Wrong - sam publish is used to make a serverless application available in the AWS Serverless Application Repository (SAR), not to redeploy a private application.

14. Explain
A. Wrong - All at once updates all instances at the same time, leading to zero capacity while the deployment is in progress.
B. Wrong - Rolling updates batches of existing instances sequentially, leading to a reduction in capacity while a batch is being updated.
C. Correct - Rolling with additional batch is a deployment policy that temporarily launches an additional batch of instances at the start of the process to maintain the full capacity of the old version while the existing instances are updated in batches. This meets the requirement of maintaining full capacity while using the existing instances.
D. Wrong - Immutable deployments launch a completely new Auto Scaling Group of instances, which does not use the existing instances (it replaces them).

15. Explain
A. Correct - The Instance Metadata Service (IMDS) is a special, unroutable service available to all EC2 instances via the well-known IP address http://169.254.169.254/latest/metadata/. The application can make an HTTP request to this service to retrieve its metadata, including the public IPv4 address.
B. Wrong - latest/userdata/ retrieves the user data (a script/configuration that runs when the instance is launched), not the instance's public IP address.
C. Wrong - Running operating system commands like IFCONFIG (Linux/macOS) inside the instance will primarily return the private IP address and possibly the OS's view, but the official way to retrieve the public IPv4 assigned by AWS is via IMDS.
D. Wrong - Running operating system commands like IPCONFIG (Windows) inside the instance will primarily return the private IP address and possibly the OS's view, but the official way to retrieve the public IPv4 assigned by AWS is via IMDS.

Tuyệt vời, tôi sẽ tiếp tục giải thích các câu hỏi AWS DVA còn lại theo đúng định dạng bạn yêu cầu và đặt tất cả vào khung.
________________________________________
## AWS DVA Question Explanations

16. Explain
A. Wrong - Creating a single API Gateway with three stages requires provisioning cache for the entire resource, and provisioning 237 GB of cache across all three stages constantly is expensive, especially if development and test are only used occasionally.
B. Wrong - Creating three API Gateways is more complex to manage and provision 237 GB of cache on each one permanently is the most expensive option.
C. Wrong - Creating API Gateways in three separate AWS accounts adds administrative complexity and does not solve the underlying cost issue of permanent cache provisioning.
D. Correct - API Gateway cache is expensive. The most cost-efficient strategy is to provision the full cache size only for the production stage, and for the development and test stages, enable the cache only when needed (e.g., during testing cycles) and disable it afterward to save costs.

17. Explain
A. Wrong - Vertical scaling (increasing instance size) and database retries help with handling load and temporary failures but are not a refactoring strategy specifically for optimizing read performance under read-heavy workloads.
B. Wrong - Multi-AZ deployment is for high availability and disaster recovery (failover), not for scaling read performance.
C. Correct - For read-heavy workloads on Amazon RDS, the best architectural pattern is to offload read queries to one or more Read Replicas. The application code must be refactored to use a separate connection string specifically targeting the Read Replica endpoint for all read operations.
D. Wrong - While you could run a replica on EC2, this loses the benefits of a managed RDS Read Replica, which is the standard solution for read scaling in RDS.

18. Explain
A. Correct - The Event-driven architecture pattern uses events (in this case, data inserts into DynamoDB) to trigger processing (e.g., via DynamoDB Streams and AWS Lambda). This enables the data to be processed and analyzed as soon as it is received, providing near-real-time results, rather than waiting for a nightly batch.
B. Wrong - Client served driven is not a standard application architecture pattern for real-time data processing.
C. Wrong - Fan-out driven is a messaging pattern where one message triggers multiple actions, which is often part of an event-driven architecture, but "Event driven" is the correct top-level pattern.
D. Wrong - Schedule driven architecture (like a nightly batch) is precisely what the analysts want to replace, as it introduces latency.

19. Explain
A. Wrong - Moving the application to a larger EC2 instance affects the *client* (the application) but does not resolve the ProvisionedThroughputExceededException, which is an error thrown by the *DynamoDB server* when the provisioned capacity (RCUs/WCUs) is insufficient.
B. Wrong - Increasing the number of RCUs would resolve the issue, but the question asks for actions a developer should take, and increasing RCUs might not be the most immediate or cost-efficient solution if the burst is short-lived.
C. Correct - When a `ProvisionedThroughputExceededException` occurs, the application must retry the failed request. Implementing **exponential backoff** (waiting a progressively longer time between retries) is the standard and necessary practice to handle throttling errors, reduce the request frequency, and resolve the issue.
D. Wrong - Increasing the frequency of requests will make the throttling issue worse.
E. Correct - Changing the table capacity mode from **Provisioned** to **On-Demand** eliminates the need to manage capacity units, allowing the table to instantly adapt to almost any traffic level. This is a definitive solution for burstable/unpredictable traffic patterns that cause throttling.

20. Explain
A. Wrong - Server-side encryption with Amazon S3 managed keys (SSE-S3) is fully managed by AWS but does **not** give the company control over the encryption keys.
B. Wrong - Server-side encryption with customer-provided encryption keys (SSE-C) allows the company to manage the keys, but it requires them to **manage the keys in-house** and transmit the key with every request, which violates the requirement of not managing the security infrastructure in-house.
C. Correct - Server-side encryption with **AWS KMS managed keys (SSE-KMS)** meets both requirements:
    1. The encryption service itself is managed by AWS (**no in-house security infrastructure management**).
    2. The company maintains **control over the encryption keys** (via IAM policies and audit trails in CloudTrail) because the keys are stored in a dedicated KMS service controlled by the company's AWS account.
D. Wrong - Client-side encryption is complex to implement and manage and requires the company to run encryption logic on its clients, which is not the simplest solution for at-rest encryption.

21. Explain
A. Wrong - The maximum number of consumers is tied to the number of shards.
B. Correct - **Kinesis Client Library (KCL)** assigns one worker (EC2 instance in this case) to process data from exactly one shard. Since the maximum number of shards is 6 after resharding, the maximum number of KCL workers (EC2 instances) that can be utilized to process the data concurrently is **6**. 
C. Wrong - 4 was the initial number of shards.
D. Wrong - 1 is the minimum number of instances.

22. Explain
A. Wrong - AWS Lambda requires creating a backend application to manage user data, which the requirement explicitly prohibits.
B. Wrong - Amazon S3 is for object storage and does not natively provide device synchronization functionality.
C. Wrong - Amazon DynamoDB is a database but requires a backend application (like Lambda or EC2) to handle authentication, access control, and the synchronization logic across devices.
D. Correct - **Amazon Cognito** is a service that provides user authentication, authorization, and user management. Critically, its **Sync component (Cognito Sync)** allows you to store and synchronize application-related user data, such as game state or preferences, across multiple devices for the same user **without the need to write backend code**.

23. Explain
A. Correct - The most common way to deploy a new version via the console is to package the application code into a **.zip** file, upload it directly through the Elastic Beanstalk console, and then select "Deploy" to apply it to the environment.
B. Wrong - Elastic Beanstalk typically accepts **.zip** or **.war** files for deployment, and while the AWS CLI can be used, using a **.tar** file directly for a new application version deployment is not the standard or simplest console method.
C. Wrong - Elastic Beanstalk typically accepts **.zip** or **.war** files for deployment, not **.tar** files.
D. Correct - For automated or command-line deployments, the process is: package code into a **.zip** file, use the **AWS CLI** or EB CLI to create a new application version from that packaged file, and then use the **AWS CLI** or EB CLI to update the environment with the new version.
E. Wrong - You update the environment; you do not "rebuild" the environment to deploy a new application version.

24. Explain
A. Correct - The **`/tmp` directory** in a Lambda execution environment is high-speed, ephemeral storage that is preserved for the life of the execution environment (the container). Since the function is called multiple times a second, the container is likely to be reused (a "warm start"). Caching the 50MB file in `/tmp` on the first execution will allow subsequent executions to read the file locally, **eliminating the need to download it from the Internet repeatedly**, leading to the **BEST performance increase** and saving outbound network costs.
B. Wrong - Increasing the maximum execution time only allows a single function call more time to complete, but it doesn't speed up the overall execution time of the download.
C. Wrong - An Elastic Load Balancer (ELB) distributes traffic to multiple Lambda functions; it does not affect the performance of the function's internal logic (like downloading a file).
D. Wrong - Caching the file in Amazon S3 is redundant, as the file is already there. Downloading from S3 still involves network latency, whereas reading from `/tmp` is local file system access.

25. Explain
A. Wrong - Batching writes is a good practice for write throughput but does not address the cost or performance issues related to high read capacity consumption and large attributes.
B. Correct - The cost of reads in DynamoDB is based on **Read Capacity Units (RCUs)**, which are consumed by the size of the item read. When an application only needs a few attributes but reads a large item, it wastes RCUs. A **Global Secondary Index (GSI)** with a **minimum set of projected attributes** (i.e., only the attributes the application actually needs) allows the application to query the GSI instead of the main table. Because the item in the GSI is smaller, fewer RCUs are consumed per read, which **minimizes costs** and **maximizes performance** (by reducing I/O).
C. Wrong - Implementing exponential backoffs addresses throttling errors (when capacity is *exceeded*) but does not reduce the overall capacity consumed or the cost of the reads themselves.
D. Wrong - Application Load Balancers (ALBs) cannot be used to load balance reads to an Amazon DynamoDB table.

26. Explain
A. Wrong - Enabling request validation only ensures the incoming request meets defined rules; it doesn't handle data transformation.
B. Wrong - Including the Lambda ARN is part of the integration setup, not the data transformation step.
C. Wrong - Changing the integration type (e.g., from Lambda Proxy to Lambda) changes the overall request handling, but a **mapping template** is still needed to precisely control data transformation.
D. Correct - To convert input data (like query string parameters) from the client request format into a specific JSON structure that the Lambda function expects as arguments, the Developer must define a **Mapping Template (or Body Mapping Template)** in the API Gateway Integration Request. This template uses VTL (Velocity Template Language) to perform the necessary data transformation.

27. Explain
A. Wrong - Using an IAM role to assume another role is the MOST secure way for an **EC2 instance** or **another AWS service** to access resources (using temporary credentials), but it is overly complex for a local development machine setup.
B. Wrong - Sharing one IAM user access key among the entire team is a major **security risk** and makes accountability and key rotation impossible.
C. Correct - The simplest and **MOST secure** way for individual developers to access AWS services from their local machines is to give **each developer a unique IAM user** and provide them with their own unique, non-shared **access key/secret key pair**. This allows for individual auditing, easy key rotation, and revocation when a developer leaves.
D. Wrong - Setting up federation through an Amazon Cognito user pool is the standard for web/mobile users, but is complex and unnecessary for a small team of internal developers needing API access.

28. Explain
A. Wrong - The consistency model has a direct, fixed impact on provisioned throughput usage.
B. Correct - DynamoDB is engineered such that one **strongly consistent read** consumes **one full Read Capacity Unit (RCU)** for items up to 4KB. In contrast, one **eventually consistent read** consumes only **half (0.5) of an RCU** for items up to 4KB. Therefore, strongly consistent reads effectively **use more throughput** (cost double the RCUs) than eventually consistent reads for the same amount of data.
C. Wrong - Strongly consistent reads use double the throughput of eventually consistent reads.
D. Wrong - The throughput usage is fixed and deterministic (1 RCU vs 0.5 RCU per 4KB), not variable based on activity beyond the actual reads performed.

29. Explain
A. Correct - The simplest way for a developer to deploy a new application version is to package the new code and use the **Elastic Beanstalk Console** to upload and deploy the new application version directly to the environment.
B. Wrong - `eb init` is used to **initialize** a new Elastic Beanstalk application directory, not to deploy a new version. The `eb deploy` command is used for deployment with the EB CLI.
C. Wrong - Terminating and recreating the environment is known as "immutable deployment" or blue/green deployment, but it is **not the simplest** method for a standard update; it involves unnecessary downtime or extra resources compared to a direct update.
D. Wrong - Modifying the `ebextensions` folder is used for customizing the environment's resources or settings during deployment, not for specifying the source code package to be deployed.

30.Explain
A. Correct - This option correctly combines the two necessary policy conditions for fine-grained access control in DynamoDB:
    1. dynamodb:LeadingKeys: This must match the Partition Key of the item being accessed. Since the user ID is the primary way to identify the user, and the user is authenticated via web identity federation (Amazon, Facebook, Google, etc.), the `user_id` is derived from the user's identity provider ID (`${www.amazon.com:user_id}`). This ensures the user can only update their own record.
    2. dynamodb:Attributes: This specifies the **only attributes** the user is allowed to modify in the request. By limiting it to ["user_name"], the user is prevented from changing protected attributes like `user_score` or `user_rank`.
B. Wrong - This uses `user_name` for `LeadingKeys`, which is generally not used as a primary key, and it uses `user_id` in `dynamodb:Attributes`, which is typically not an attribute a user should be allowed to modify during an update.
C. Wrong - This includes `user_id` in `dynamodb:Attributes`. The `user_id` is the key and should generally not be allowed to be modified by the user themselves in an update request; they should only update the `user_name`.
D. Wrong - This uses `user_name` for `LeadingKeys` and includes both `user_name` and `user_id` in the updatable attributes, which is incorrect for a secure update operation tied to the user's identity.

31.Explain
A. Wrong - This describes a "Big Bang" deployment (deploy and then switch the alias), which has a high impact on users because 100% of traffic is sent to the new version instantly, making rollback necessary if errors occur.
B. Correct - This describes a **Canary Deployment** strategy using Lambda aliases. By directing only a **small percentage (e.g., 10%)** of traffic to the new version, the impact of potential errors is limited to that small user group. If errors increase, the traffic weight is immediately set back to **0% (100% to the old version)**, achieving a rollback with minimal overall user impact.
C. Wrong - This is a "Big Bang" deployment without using aliases, which is high-impact and non-standard for safe rollbacks. Aliases and versions are the recommended way to manage deployment and rollback in Lambda.
D. Wrong - This describes an overly complicated, unnecessary use of multiple aliases ("new," "existing," "router"). Lambda aliases already support weighted traffic shifting, making this multi-alias setup redundant.

32.Explain
A. Wrong - Deploying both components in a single environment forces them to scale together (co-scaling) and couples their lifecycle, which violates the requirement that **each component must scale independently**.
B. Correct - To ensure that the HTTP component (which handles user requests and scales based on latency/load) and the background worker component (which handles tasks from a queue and scales based on queue depth) can **scale independently**, they must be deployed into **separate Elastic Beanstalk environments**.
C. Wrong - Using multiple environments for one component and one for the other doesn't address the need for both to be independently scalable.
D. Wrong - Using multiple environments for one component and one for the other doesn't address the need for both to be independently scalable.

33.Explain
A. Correct - A **Change Set** in AWS CloudFormation is a preview of the changes that will be made to your stack based on a new template. It details which resources will be **modified, replaced, or deleted**, allowing the company to investigate the potential impact *before* executing the update.
B. Wrong - Stack policies define which resources can be **updated** during a stack update (a form of protection), but they do not show *what* the changes will be.
C. Wrong - The `Metadata` section is for providing information about the template itself (e.g., descriptions or configuration details), not for previewing stack changes.
D. Wrong - The `Resources` section defines the resources, but investigating this section in the new template only shows the *desired state*, not the *difference* or *impact* on the current running resources.

34.Explain
A. Wrong - Associating different Lambda functions to an API Gateway target endpoint would require updating the API Gateway every time the target changes, which the developer wants to avoid.
B. Wrong - While creating different stages is necessary for environments (dev, test, prod), it doesn't solve the issue of updating the target endpoint for every code push within a branch.
C. Correct - By using **Lambda Versions** for code releases and **Lambda Aliases** (e.g., `dev-alias`, `test-alias`) to point to the desired version, the **API Gateway integration can be configured to point to the stable Lambda Alias ARN**. When a new code push occurs, the developer only needs to **update the Alias to point to the new Version**, which does *not* require updating the API Gateway configuration, achieving the desired efficiency.
D. Wrong - Tagging Lambda functions is for resource organization and cost allocation, not for managing deployment targets in API Gateway.

35.Explain
A. Wrong - Installing certificates on EC2 instances is necessary for the EC2 instance to serve HTTPS, but it does not mandate that the client (the application on EC2) uses HTTPS when sending requests *to S3*.
B. Wrong - A bucket policy that **allows** traffic where `SecureTransport` is `true` is good, but it doesn't *prevent* unencrypted (HTTP) traffic, which is required by the mandate.
C. Wrong - Creating an HTTPS redirect on the EC2 instance affects *incoming* requests to the EC2 instance, not *outgoing* requests from the EC2 instance to S3.
D. Correct - The most effective way to enforce encryption in transit is to use a **Bucket Policy that explicitly denies any request to S3 that does not use SSL/HTTPS**. This policy uses the global condition key `aws:SecureTransport` and sets the action to `Deny` when the value is `false`, forcing all clients, including the EC2 instance, to use HTTPS.

36.Explain
A. Wrong - Amazon SQS and SNS are messaging services for asynchronous communication, not suitable for serving a real-time, synchronous **RESTful API endpoint** like `/status/customerID`.
B. Correct - **Elastic Load Balancing (ELB)** and **Amazon EC2** form the classic, scalable architecture for hosting a **RESTful API** web service. The ELB handles traffic distribution, and the application running on EC2 instances serves the requested endpoint.
D. Correct - **Amazon API Gateway** and **AWS Lambda** form the modern **serverless** architecture for serving a **RESTful API**. API Gateway handles the endpoint definition, request routing, and security, and Lambda executes the business logic to query the order status, fully meeting the requirements.
C. Wrong - ElastiCache is for caching; Elasticsearch Service is for full-text search and analytics. Neither is suitable on its own for creating and serving a transactional REST API endpoint.
E. Wrong - Amazon S3 and CloudFront are designed for hosting static websites and distributing static content, not for executing dynamic server-side logic required to query a customer's order status.

37.Explain
A. Correct - The **`/tmp` directory** is the only location within the standard AWS Lambda execution environment that is available for temporary, writable storage. Since the files are less than 10 MB (well within the max size of the `/tmp` directory, which is 512 MB to 10 GB depending on function configuration) and only needed during the invocation, this is the most efficient and appropriate place to store them.
B. Wrong - Amazon EFS (Elastic File System) provides persistent network file storage, which is unnecessary and complex for temporary files that are not saved or retrieved later.
C. Wrong - Amazon EBS (Elastic Block Store) volumes cannot be directly attached to AWS Lambda functions.
D. Wrong - Amazon S3 is for persistent object storage. Writing and reading files multiple times to S3 incurs network latency and API charges, which is highly inefficient for temporary execution-time files.

38.Explain
A. Wrong - Running a database on a new EC2 instance for caching is complex, non-managed, and ElastiCache is the purpose-built, more efficient solution.
B. Correct - **Amazon ElastiCache** (Redis or Memcached) is the dedicated, high-performance, in-memory caching service. The **Cache-Aside** strategy is most efficient when reading user profiles: the application checks the cache first (fast). If the profile is missing (cache miss), it fetches the data from the database, serves the request, and then writes the data into the cache (to serve the next request quickly). This is simple to implement and minimizes database load.
C. Wrong - Using a dedicated RDS instance for caching is inappropriate; RDS is a relational database, not an optimized in-memory cache.
D. Wrong - The **Write-Through** strategy (writing data simultaneously to cache and database) is used when consistency is paramount *during writes*. For read-heavy, latency-sensitive profile loading, **Cache-Aside** is generally preferred because it only caches data that is actually requested, reducing memory usage and providing better read performance optimization.

39.Explain
A. Wrong - AWS VM Import is for lift-and-shift of existing VMs. While feasible, it requires the company to manage the OS and all web server components, which is not the BEST solution for handling scaling and management.
B. Wrong - Amazon Lightsail is a simpler, fixed-price solution. While it includes load balancing, it is less flexible and scalable than a full Elastic Beanstalk solution using Auto Scaling for heavy traffic.
C. Correct - **AWS Elastic Beanstalk** is a fully managed service that simplifies deployment, management, and scaling. It handles provisioning the EC2 instances, setting up **Auto Scaling**, managing the load balancer, and monitoring. This meets the requirement to manage everything **except website development** by providing a hands-off infrastructure management experience that can handle heavy traffic.
D. Wrong - Amazon S3 is only suitable for **static** websites. Since the question implies a **dynamic** website (which is typical for an advertising company), this solution is inappropriate.

40.Explain
A. Correct - AWS Lambda automatically injects a **Context Object** into the function handler. This object contains metadata about the invocation, including the **`aws_request_id`** (or equivalent in the specific runtime), which is a **unique identifier** for that specific function invocation. By designing the application to **write logs to the console** (e.g., `console.log` in Node.js, `print()` in Python), the Lambda service automatically captures these logs and streams them to **AWS CloudWatch Logs**. CloudWatch automatically associates these log events with the unique request ID, achieving the objective.
B. Wrong - The **Event Object** contains the *input* data that triggered the function, not the invocation's unique request ID. Writing logs to a file is incorrect; Lambda requires logs to be written to the console/stdout.
C. Wrong - The **Event Object** does not contain the invocation's unique request ID.
D. Wrong - Writing logs to a file is incorrect; Lambda requires logs to be written to the console/stdout.

41.Explain
A. Correct - In cross-account access using IAM roles, the IAM role of the calling entity (the EC2 IAM role in Account B) must be explicitly granted the permission to assume the target role (AccessPII in Account A) via an `sts:AssumeRole` action in its policy.
B. Wrong - The EC2 IAM role should not be given direct permission to the PII table; instead, it gains access by assuming the AccessPII role, which holds the table permissions. This is the foundation of secure cross-account access.
C. Wrong - The application should obtain temporary credentials by calling the `AssumeRole` operation, not by trying to obtain credentials from its own EC2 IAM role to access a *cross-account* resource.
D. Correct - To access the cross-account resource, the application logic must include the **AssumeRole** API operation (part of the AWS Security Token Service - STS) to exchange its EC2 role's credentials for **temporary credentials** associated with the AccessPII role in Account A.
E. Wrong - `GetSessionToken` is used to federate a user or retrieve temporary credentials for an existing IAM user, not for cross-account role assumption.

42.Explain
A. Wrong - Adding DynamoDB as an event source is for triggering the Lambda function (e.g., via Streams). CloudWatch metrics provide high-level performance data (like duration, memory usage) but not detailed API call timing breakdown.
B. Wrong - An Application Load Balancer is used for HTTP/HTTPS traffic and cannot be placed in front of DynamoDB tables.
C. Wrong - Limiting concurrency is a performance control measure, not a method for inspecting and identifying timing bottlenecks.
D. Correct - **AWS X-Ray** is the service designed for tracing and analyzing application performance, particularly for serverless applications. By enabling X-Ray tracing for the Lambda function, the developer can view detailed traces that show the **timing of every downstream API call**, including the latency for each **DynamoDB API call**, making it the ideal tool for identifying bottlenecks.

43.Explain
A. Wrong - Multi-AZ deployment provides high availability and automatic failover, but both the primary and standby instances are subject to the same write load, meaning the standby instance doesn't serve reads and thus doesn't eliminate the write impact on the primary's read performance.
B. Correct - **RDS Read Replicas** are separate, asynchronous copies of the primary database instance. By creating a Read Replica and directing all read traffic (the historical data lookups) to this replica, the write-heavy update traffic to the primary instance will **not impact the read query performance** experienced by application users.
C. Wrong - ElastiCache is an in-memory cache for **reads**, but it cannot buffer or absorb **write traffic** on the database.
D. Wrong - While DynamoDB is a good database, switching to it is an architecture redesign and doesn't solve the immediate problem of isolating read performance from the scheduled write traffic on the existing RDS database.

44.Explain
A. Wrong - **BatchWriteItem** is an uncoordinated operation; if one write fails, others may succeed, which violates the requirement for **coordinated, all-or-nothing (transactional) changes**.
B. Correct - **TransactWriteItems** is the specific DynamoDB API operation designed to support **ACID (Atomicity, Consistency, Isolation, Durability) transactions**. This operation allows the developer to group up to 10 put, update, or delete actions and ensures that **all of them succeed or all of them fail**, meeting the requirement for coordinated, all-or-nothing changes to multiple items.
C. Wrong - Amazon SQS is an asynchronous messaging service. Using a FIFO queue does not inherently guarantee transactional atomicity on the downstream DynamoDB writes; the custom backend process would still need to implement complex logic to achieve a true all-or-nothing outcome.
D. Wrong - Using Aurora and a synchronization process is overly complex, introduces significant latency, and is unnecessary, as DynamoDB natively supports transactions via `TransactWriteItems`.

45.Explain
A. Wrong - This approach introduces unnecessary complexity (S3 upload, event notification, Lambda function) and latency just to publish a simple metric.
B. Wrong - This approach uses Kinesis and Lambda, which is overly complicated and adds latency and cost compared to a direct API call.
C. Wrong - While the `PutMetricData` API call is correct, requiring the application to provide specific credentials (like an access key/secret key) is poor security practice for an EC2 instance.
D. Correct - The best practice for applications running on EC2 instances to interact with AWS services is to use an **IAM Role for EC2**. By launching the instance with an IAM role that has the necessary **CloudWatch `PutMetricData` permission**, the application can use the AWS SDK to make the API call **without ever needing to manage or store explicit credentials**, making it the most secure and robust solution.

46.Explain
A. Wrong - The standard Amazon SQS CLI cannot handle messages up to 1GB. The standard maximum message size is 256KB.
B. Correct - The standard SQS message size limit is 256KB. To handle messages up to 1GB, the developer must use the **Amazon SQS Extended Client Library for Java**. This library automatically integrates with **Amazon S3** to store the message payload (the large file) in a designated S3 bucket, while the SQS message itself only contains a small reference pointer to the S3 object, allowing the application to manage large messages seamlessly.
C. Wrong - Amazon EBS (Elastic Block Store) is block storage that cannot be used directly to store large SQS payloads; S3 is the correct object storage service used by the Extended Client Library.
D. Wrong - Amazon EFS (Elastic File System) is file storage that cannot be used directly to store large SQS payloads; S3 is the correct object storage service used by the Extended Client Library.

47.Explain
A. Wrong - AWS X-Ray is for tracing application *requests* and analyzing latency. While it can handle custom data, it is not the service designed for long-term **time-series data graphing** of operational metrics like thread count.
B. Correct - **Amazon CloudWatch** is the purpose-built service for collecting and visualizing metrics. The most efficient way to fulfill this request is to create a **Custom CloudWatch Metric** (e.g., "RunningThreads") and have the application periodically use the **`PutMetricData` API call** to send the current thread count to this metric. CloudWatch can then automatically generate a **graph over time** for monitoring purposes.
C. Wrong - Logging data to S3 and then processing it with Kinesis is an overly complicated, multi-step data pipeline suitable for analytics, not for simple, real-time operational monitoring and graphing.
D. Wrong - Using DynamoDB for time-series data and CloudFront for graphing is an unusual, non-standard, and inefficient architecture for this simple monitoring requirement. CloudWatch is the dedicated service.

48.Explain
A. Correct - Lambda environments include various pre-packaged libraries. Packaging only the modules the function explicitly requires reduces the size of the deployment package. A smaller package leads to **faster cold start times** (the time it takes for AWS to download and unpack the code), thus improving performance without increasing cost.
B. Wrong - Using DynamoDB instead of RDS would require a complete architecture change (refactoring) and would likely **increase costs** for a fully relational workload. The question asks for actions *without* increasing the cost.
C. Correct - In the pseudocode, the RDS connection object is created *inside* the `lambda_handler` function. This forces the function to re-establish a **new, high-latency TCP connection** to the database on every single invocation (both cold and warm starts). Moving the connection logic **outside the handler** allows the connection object to be reused across subsequent *warm* invocations of the same container, significantly reducing latency and improving performance without increasing the function's cost (memory/duration).
D. Wrong - Implementing custom database connection pooling is complex and primarily addresses resource contention on the *database side*, but the most significant latency is the *connection setup* itself, which is solved by moving the connection outside the handler.
E. Wrong - Implementing local caching (in /tmp) would improve read performance but requires complex custom logic and would likely increase the function's memory (cost) to hold the cache data.

49.Explain
A. Wrong - Simple Email Service (SES) is for sending emails. While it can be used for notifications, the standard AWS service for pushing notifications to various endpoints (including email, SMS, SQS, Lambda) is **SNS**. Also, there is no built-in CloudWatch API-error metric for *third-party* APIs; you must use a custom metric.
B. Wrong - There is no built-in CloudWatch API-error metric for *third-party* APIs; you must use a custom metric.
C. Wrong - There is no built-in CloudWatch API-error metric for *third-party* APIs, and SNS is the preferred notification service over SES for this purpose.
D. Correct - To monitor errors from **third-party APIs**, the developer must add logic to the application to capture these errors and publish a **Custom Metric on Amazon CloudWatch** (e.g., "ThirdPartyAPI/FailureCount"). Once the failure count exceeds a threshold, an **Amazon CloudWatch Alarm** is used to trigger an **Amazon Simple Notification Service (SNS) Topic** to send the notification.

50.Explain
A. Wrong - While multiple pipelines could be structured to wait, this is overly complex and unnecessary.
B. Correct - **AWS CodePipeline** is designed to support manual intervention in its workflow using the **Approval Action**. By adding an Approval Action in a stage (typically just before the production deployment stage), the pipeline pauses and requires a designated IAM user to explicitly approve or reject the transition before the deployment proceeds. This is the **BEST and simplest** way to implement manual gates.
C. Wrong - Disabling the stage transition prevents *any* movement, but doesn't provide the explicit approval mechanism or notification that the Approval Action offers.
D. Wrong - Disabling a stage means the stage will simply be skipped or stop running; it doesn't provide the controlled pause and approval required.

51.Explain
A. Correct - **Amazon ElastiCache Redis** offers both high performance and **data persistence** (via snapshots), meaning the cached content can be recovered in case of failure. Furthermore, running in **Cluster Mode** provides high availability, replication, and partitioning, ensuring **maximum uptime** and fault tolerance for the caching layer.
B. Wrong - Installing Redis on an EC2 instance requires the developer to manage everything (HA, backups, patching), leading to lower uptime guarantees and higher management overhead than a managed service.
C. Wrong - **Amazon ElastiCache Memcached** is a simple, high-performance in-memory cache, but it **does not offer data persistence or replication**, meaning all cached content would be lost upon service failure, which violates the requirement for protecting expensive-to-regenerate content.
D. Wrong - Amazon Redshift is a data warehousing service, not a caching layer, and requires significant refactoring.

52.Explain
A. Correct - The test environment (EC2 instance) used 1GB of RAM. If the Lambda function's **allocated memory** is significantly lower (e.g., 128 MB or 256 MB), the large image conversion process will quickly run out of memory. When a Lambda function runs out of memory, it results in an unhandled exception and **terminates immediately**, preventing the subsequent S3 copy operations from executing. Increasing the Lambda memory to **1 GB** should resolve the immediate failure.
B. Wrong - Files do not need to be in the same S3 bucket for processing; a Lambda function can interact with any S3 bucket it has permission for.
C. Wrong - The maximum execution limit is 15 minutes (900 seconds), and the function takes 500 seconds, so the time limit is unlikely to be the cause of failure (though the long execution time is highly inefficient).
D. Wrong - There is no general problem with the Java runtime for Lambda.

53.Explain
A. Wrong - Enabling SSL connections encrypts data **in transit** (between the producer/consumer and Kinesis), not **at rest** (while stored in the stream).
B. Wrong - The Kinesis Consumer Library (KCL) is for consuming data, not for configuring server-side encryption.
C. Wrong - Kinesis Streams retains data for up to 12 hours *before* consumption. Encryption must be applied to the stream itself to protect the data while it is being stored there; a Lambda function can only encrypt data *after* it has been consumed.
D. Correct - To implement **encryption at rest** for data stored within Kinesis Streams, the developer must simply **enable server-side encryption (SSE)** on the Kinesis Stream itself. This uses AWS KMS keys to encrypt the data as soon as it is written to the stream, protecting it during the 12-hour retention period.

54.Explain
A. Wrong - AWS Lambda requires creating custom backend code for user authentication and managing the SAML integration, which is inefficient and costly compared to a managed service.
B. Correct - **Amazon Cognito** is the dedicated service for customer identity and access management. It directly supports **federation with SAML 2.0 identity providers** (IdPs) and handles user signup/authentication. It is highly **scalable** and, as a managed service, is the **most cost-efficient** solution for handling customer authentication in a mobile application.
C. Wrong - AWS IAM is for managing users/roles within an AWS account, not for external customer authentication via SAML.
D. Wrong - Amazon EC2 requires building the entire authentication platform from scratch, which is complex, costly, and violates the principle of using scalable, managed services when possible.

55.Explain
A. Wrong - An Amazon SNS topic is a notification service; it cannot be used directly as the metric source for Auto Scaling decisions.
B. Wrong - The CloudWatch `NetworkIn` metric measures network bytes flowing into the instance; it is a *proxy* for traffic but not a direct or accurate measure of **concurrent users**.
C. Wrong - Amazon CloudFront is a CDN; it is used for content delivery, not for measuring internal application metrics to drive Auto Scaling.
D. Correct - Auto Scaling can scale based on any metric. Since the required metric is **concurrent users** (which is not a standard CloudWatch metric), the developer must write the application logic to measure this value and then publish it to **Amazon CloudWatch as a Custom Metric**. The Auto Scaling policy can then be configured to scale up/down based on the values of this custom metric.

56.Explain
A. Wrong - Deploying using the Lambda API operations is possible but requires complex scripting and management of dependencies (layers) and API Gateway configuration, which is not easily rollback-enabled.
B. Wrong - Using standard **AWS CloudFormation** syntax for a serverless application is overly verbose and requires manual management of deployment packages and function properties, which is prone to error and complexity when defining all the API Gateway endpoints.
C. Correct - The **Serverless Application Model (AWS SAM)** is an extension of AWS CloudFormation that provides a simplified, shorthand syntax specifically for defining serverless resources (Lambda functions, API Gateway, DynamoDB, etc.) as a single stack. Crucially, the **SAM CLI** builds the deployment package, manages the code/APIs, and handles the **CloudFormation deployment**, which inherently supports **safe deployment rollbacks** (via CloudFormation's update/rollback mechanisms) for the entire application stack.
D. Wrong - A bash script using the AWS CLI is a manual approach that lacks the built-in rollback and resource dependency management offered by CloudFormation/SAM.

57.Explain
A. Wrong - Encrypting data with individual user keys protects the data, but the application still needs fine-grained access control on the **read operation** itself to prevent one user from reading another's encrypted data.
B. Correct - **Fine-Grained Access Control (FGAC)** in DynamoDB is accomplished by using IAM policies with **DynamoDB condition keys**. The policy should restrict the `dynamodb:GetItem` or `dynamodb:Query` operation by ensuring that the **partition key value** in the request (`dynamodb:LeadingKeys`) matches the **authenticated user's ID** (e.g., derived from Amazon Cognito or a federated identity). This ensures that each individual user can only access items where the key matches their own ID.
C. Wrong - SQS is for messaging; it does not provide access control logic for DynamoDB.
D. Wrong - Reading all records and discarding irrelevant data client-side is a huge waste of read capacity and exposes all user data to every client, which is a major security violation.

58.Explain
A. Wrong - AWS STS provides temporary credentials but is primarily for IAM users/roles/federation; it does not offer the simple, integrated solution for both authenticated and guest access.
B. Wrong - Amazon Directory Service provides managed Microsoft AD and Simple AD for enterprise identities, not for consumer/mobile application authentication.
C. Correct - **Amazon Cognito** is the service designed for mobile and web application identity management. It allows developers to create User Pools for authenticated users. Importantly, its **Identity Pools** feature allows developers to enable **unauthenticated access (Guest Access)**, providing temporary, limited AWS credentials to users who have not yet signed in. This meets the requirement for supporting both authenticated and limited guest access seamlessly.
D. Wrong - IAM with SAML integration is for enterprise federation, not for general mobile application guest access.

59.Explain
A. Wrong - AWS CloudFormation compile is not a standard command, and embedding the source code by base64 encoding directly into the template is inefficient and hits template size limits.
B. Correct - The `aws cloudformation deploy` command requires that local artifacts (like the `store.py` source file referenced implicitly in the `AWS::Serverless::Function` resource) are available in S3. The standard process is to first use the **`aws cloudformation package`** command (or `sam package` when using the SAM transform) to **upload the source code to a specified S3 bucket** and generate a new, modified CloudFormation template where the local code references are replaced with the S3 object URLs.
C. Wrong - AWS Lambda zip is not a standard CLI command used for preparing a CloudFormation template for deployment. The CloudFormation/SAM toolchain manages this process.
D. Wrong - There is no `aws serverless create-package` command, and the source file cannot be embedded directly into the template for standard deployment due to size limits.

60.Explain
A. Wrong - The error explicitly states "Unzipped size must be smaller than XXXXXXXXX bytes," referring to the hard limit for the *unzipped* deployment package size. This is not a soft quota that can be increased via a support request.
B. Wrong - The ZIP compression ratio only affects the *on-disk* size, not the *unzipped* size, which is the cause of the error.
C. Correct - The maximum unzipped deployment package size for a Lambda function is a hard limit. To fix this, the developer must adhere to the limit by reducing the size of the code and dependencies. The best approach is to **break the large function into multiple smaller Lambda functions** and have them communicate, or use **Lambda Layers** to share common dependencies.
D. Wrong - Zipping a ZIP file twice offers negligible additional compression and does not address the unzipped size limit.

61.Explain
A. Correct - AWS Lambda functions are stateless and their execution environment (container) is ephemeral. Session information must be stored in an **external, persistent, high-speed store**. **Amazon DynamoDB** is a high-performance, fully managed NoSQL database that is ideal for storing session data due to its low latency and scalability.
B. Wrong - Amazon SQS is a message queue; it's used for asynchronous communication, not for storing session data for retrieval.
C. Wrong - The local filesystem (`/tmp`) is ephemeral and tied to a specific execution container, which can be terminated at any time. Session data would be lost or inaccessible to other function calls.
D. Wrong - SQLite requires a database file on the local filesystem, which is ephemeral and thus unsuitable for persistent session storage.

62.Explain
A. Wrong - Creating a new GSI only helps with read performance if the existing primary key or query pattern is inefficient; it doesn't directly solve intermittent throttling errors caused by brief peaks in demand.
B. Correct - The `ProvisionedThroughputExceeded` error is a **throttling** error indicating a brief, temporary spike above the provisioned capacity. The **best practice** for handling intermittent throttling is to **retry the failed read requests with exponential backoff**. This automatically manages the temporary load spike by spacing out retries, thus resolving the issue without manual intervention or over-provisioning.
C. Wrong - Immediately retrying the failed read requests only increases the immediate request rate, which guarantees more throttling errors.
D. Wrong - Using `UpdateItem` is for modifying table data, not capacity. Furthermore, manually increasing capacity for a 15-second spike is inefficient and would require constantly monitoring and scaling down again, making it overly complicated and costly.

63.Explain
A. Wrong - **Immutable** deployment maintains full capacity by launching a *new* fleet, but it requires *new* instances, increasing cost. The question specifically asks for minimizing cost while maintaining full capacity.
B. Wrong - **Rolling** deployment updates batches of *existing* instances, which temporarily reduces the available capacity.
C. Wrong - **All at Once** deployment updates all instances simultaneously, resulting in a period of zero capacity and downtime.
D. Correct - **Rolling with additional batch** updates batches of the *existing* instances (minimizing cost by reusing existing resources), but it **temporarily launches an "additional batch"** of instances *first* to ensure that the environment maintains **full capacity** during the entire update process. This meets both requirements: full capacity and minimizing cost by reusing existing instances.

64.Explain
A. Wrong - While it might improve legibility, the primary reason is functional, not stylistic.
B. Correct - Instantiating AWS clients (like `S3Client` or `DynamoDBClient`) or database connection objects **outside the handler** allows the client/connection to remain active and be **reused** by subsequent invocations that hit the same execution container (a "warm start"). This avoids the high latency and CPU overhead associated with re-creating the client object and re-establishing the underlying **TCP connection on every call**, thus **taking advantage of connection re-use** and dramatically improving performance.
C. Wrong - Error handling is typically done inside the handler function.
D. Wrong - The goal is to *avoid* creating a new instance per invocation.

65.Explain
A. Wrong - AWS Data Pipeline is primarily for data migration, transformation, and processing workflows, not for coordinating complex, legacy application state machines involving multiple Lambda functions.
B. Wrong - AWS SNS (Publish/Subscribe) and SQS (Queueing) are asynchronous messaging services; they are used for communication between components, but they do not provide the centralized, visual orchestration and state management required for a large, coordinated state machine.
C. Wrong - Amazon Elastic MapReduce (EMR) is a framework for processing large datasets using tools like Apache Hadoop and Spark, which is unrelated to managing serverless application state.
D. Correct - **AWS Step Functions** is a serverless orchestration service that allows developers to define complex workflows (state machines) graphically. It provides built-in coordination, error handling, retries, and state management for executing sequences of Lambda functions, making it the **ideal service for refactoring and managing** legacy custom state machine logic.

66.Explain
A. Wrong - An **IAM instance profile** applies the same permissions to *all* containers and services running on that host EC2 instance. This is a security risk because it grants overly broad permissions (all four services' permissions) to every single service, violating the principle of least privilege.
B. Wrong - This setup correctly creates four distinct roles but configures the **ECS service** to reference the IAM role. The correct entity to link the role to is the **Task Definition** (see D).
C. Wrong - IAM groups are for managing IAM users, not for assigning permissions to ECS services or tasks.
D. Correct - This is the **MOST secure** and recommended best practice using **IAM Roles for Tasks**.
    1. Creating **four distinct IAM roles** ensures the **least privilege** principle is met.
    2. Configuring the **ECS Task Definition** to reference the associated IAM role ensures that **only the specific container task** running that service receives those specific permissions. This allows for bin packing onto a shared EC2 instance while maintaining strict, isolated security boundaries for each service.

67.Explain
A. Correct - **AWS Step Functions** is the most efficient and **simplest** way to implement a long-running, coordinated business process. It allows the developer to define a workflow (state machine) that can execute **parallel Lambda functions** (for vendor requests), pause for up to a year, and use a **`Map` state** to wait for and **join the results** before proceeding. This service handles all the complex logic, retries, and state management.
B. Wrong - Using SQS and worker instances is complex to manage, requires writing code for the polling/joining logic, and is not serverless.
C. Wrong - Using asynchronous Lambda calls and custom joining logic is complex, difficult to maintain, and requires manual implementation of timers and state management.
D. Wrong - Amazon CloudWatch Events (now EventBridge) is primarily for simple scheduling or reacting to AWS service changes, not for complex, long-running, multi-step orchestration.

68.Explain
A. Wrong - Table Scan is expensive and consumes significant read capacity. Running an EC2 instance with a cron job adds cost and management overhead. This is not the MOST cost-effective way.
B. Wrong - Table Scan is expensive. Using Fargate for the script is serverless but doesn't solve the expensive Table Scan operation. This is not the MOST cost-effective way.
C. Wrong - Table Scan/GSI query is still required. Using a GSI with a Lambda function and a CloudWatch Event is overly complex and requires custom write logic, which is less cost-effective than a native solution.
D. Correct - **Time-to-Live (TTL)** is the **MOST cost-effective and efficient** native DynamoDB feature for automatically deleting old items. The developer only needs to:
    1. Add a **Number** attribute to the item representing the Unix epoch time 48 hours after creation.
    2. **Configure TTL** on the DynamoDB table to reference this new attribute.
    DynamoDB handles the cleanup process asynchronously and **free of charge**, which is superior to any custom solution involving scans and Lambda/EC2 scripts.

69.Explain
A. Wrong - Throttling is often caused by a brief spike above the soft limit. Contacting support should be the last step after exhausting best practices.
B. Wrong - Using the AWS CLI is just a different tool to call the same API; it doesn't prevent throttling errors caused by the application's request pattern.
C. Wrong - Removing the API call is an extreme measure that may break functionality.
D. Correct - The `ThrottlingException` error indicates that the application is making calls faster than the allowed rate. The **first best practice** to apply to any intermittent throttling error from an AWS API is to **retry the failed call with exponential backoff**. This automatically manages the temporary load spike and smooths the request pattern to avoid hitting the limit again.

70.Explain
A. Wrong - SNS and SQS provide asynchronous fanout, but SNS/SQS standard queues have limited throughput compared to Kinesis Streams, and using a queue for each application is complex to manage.
B. Wrong - SQS FIFO queues are designed for strict ordering, which limits throughput and adds unnecessary cost/complexity when high throughput is the primary requirement.
C. Wrong - Amazon Kinesis Firehose is designed to deliver data to storage/analytics services (S3, Redshift) and cannot be easily used for real-time **concurrent processing by multiple custom consumers**.
D. Correct - **Amazon Kinesis Streams** is designed for real-time processing of massive, continuous data streams with very high throughput. It uses **shards** to segment data. Multiple custom consumers (applications) can read from the stream **concurrently** at their own pace without affecting each other, making it the **BEST and most cost-effective service** for high-throughput, real-time fanout processing.

71.Explain
A. Correct - The `appspec.yml` file is the deployment configuration file that AWS CodeDeploy looks for. It **must be placed in the root of the application source code directory structure** (ZIP, JAR, or S3/GitHub repository bundle) when the revision is uploaded to CodeDeploy.
B. Wrong - Placing it in the `bin` folder is incorrect; it needs to be at the top level of the package.
C. Wrong - The `appspec.yml` file is uploaded *with* the application code to S3 (or GitHub), but the file itself needs to be inside the code bundle.
D. Wrong - While it is a configuration file, it must be in the root directory for CodeDeploy to find it.

72.Explain
A. Correct - **Amazon Kinesis Firehose** is a managed service specifically designed for loading large volumes of streaming data from many sources into AWS data stores. It can ingest data at a **very high throughput** and continuously load it into a destination like an **Amazon S3 bucket**, making it the **BEST service** for this task due to its simplicity and scalability.
B. Wrong - Amazon S3 Transfer Acceleration is a feature to speed up data transfers *to* S3 from clients over long distances using CloudFront edge locations, but it is not a centralized ingestion/buffering service like Firehose.
C. Wrong - Amazon SQS is a message queue for discrete messages and is not suitable for high-throughput, continuous data stream ingestion.
D. Wrong - Amazon SNS is a notification service and is not designed for data ingestion or storage.

73.Explain
A. Wrong - Installing dependencies *during* the handler execution is the worst approach, as it adds significant compute time (and cost) to every single invocation, not just the cold start.
B. Wrong - Creating a deployment package with the libraries included increases the cold start time because the entire package is larger and must be downloaded and unzipped on cold start. This is not the action that minimizes *compute time consumed*.
C. Wrong - Referencing libraries from S3 would require the Lambda function to download them on every cold start or every invocation (if not cached), consuming more compute time and increasing latency.
D. Correct - **Lambda Layers** are used to package and manage dependencies that are common across multiple functions. By installing the external libraries in a **Lambda Layer**, the primary function's deployment package remains small (minimizing download/unzip time), and the layer's content is mounted to the execution environment, which **reduces the time consumed** during the function's cold start compared to including them directly in the deployment package.

74.Explain
A. Correct - A table scan consumes read capacity units (RCUs). To minimize the execution time of a full table scan, the Developer should use **parallel scans**. However, to avoid affecting normal workloads, the Developer must **limit the rate** of the scan operations to consume only the spare capacity (half of the strongly consistent RCUs) during non-peak hours, ensuring the normal workload is not throttled.
B. Wrong - Sequential scans use only one worker and are the slowest method for scanning a table.
C. Wrong - Increasing RCUs during the scan operation would resolve the performance issue but would **increase the cost** of the solution, which the question implies should be avoided.
D. Wrong - Changing consistency to eventually consistent saves RCUs (0.5 RCU per 4KB read vs. 1 RCU for strongly consistent) but does **not guarantee** the scan won't impact the remaining workload, and the change might not be acceptable for the normal workload's data integrity requirements.

75.Explain
A. Correct - **Amazon CloudFront** is a Content Delivery Network (CDN). Integrating it with S3 caches the static objects at **Edge Locations** globally. This offloads the majority of GET requests from S3 and serves them from locations geographically closer to the users, dramatically improving performance and latency, which is essential for handling over 300 GET requests/second efficiently.
B. Wrong - Cross-region replication is for disaster recovery and read locality (latency) for users in other regions, but not the primary mechanism for optimizing high request rates or general performance for a global audience.
C. Wrong - Deleting server log files helps manage S3 storage costs but has no impact on GET request performance.
D. Wrong - Lifecycle rules are for managing the cost and retention of objects (e.g., archiving or deleting), not for optimizing request performance.
E. Correct - While S3 is highly scalable, its performance scales with request rate across **prefixes**. By **randomizing the key name prefixes** (e.g., adding a random hash at the start of the key name), the request load is distributed more evenly across the S3 internal partitions, which **optimizes the performance** for very high request rates (over 300/sec).

76.Explain
A. Correct - The goal is to allow external clients to use a modern **RESTful API (JSON)** while the legacy service only accepts **SOAP (XML)**. **API Gateway** acts as the protocol converter. The developer should create a RESTful API and use **mapping templates (VTL)** in the Integration Request to perform the necessary data transformation: converting the incoming **JSON payload into the specific XML format** required by the backend SOAP interface.
B. Wrong - An Application Load Balancer (ALB) is a load balancer; it cannot perform the required protocol (JSON to XML) or data transformation.
C. Wrong - An Application Load Balancer (ALB) cannot perform data transformation. The incoming request from the client will be JSON, not XML.
D. Wrong - The incoming API Gateway request from the external client will be **JSON**, not XML, and the template should transform JSON to XML.

77.Explain
A. Wrong - S3 does not throttle the encryption rate using KMS in this manner; the throttling happens at the KMS service level.
B. Correct - **SSE-KMS** requires the application to make a separate API call to **AWS KMS** to retrieve the data key needed for each object encryption (or decryption). Since the application is performing **tens of thousands of uploads per second**, it is highly likely exceeding the default **KMS API request limits** (the number of transactions per second, or TPS) for key generation/use. This throttling by KMS results in retries and overall **increased application latency**.
C. Wrong - Client-side encryption is not being used here; the question specifies **Server-Side Encryption with KMS (SSE-KMS)**.
D. Wrong - While aliases are recommended, the requirement to use an alias has no direct impact on the performance throttling caused by exceeding the KMS TPS limit.

78.Explain
A. Correct - The **Rolling** deployment policy updates batches of **existing instances** sequentially. This ensures that the application **access logs are retained** on the existing instances and keeps the **outage minimal** (only a fraction of capacity is down at any time) while using only the existing resources.
B. Wrong - **All at Once** causes a full outage/downtime because all instances are updated simultaneously.
C. Wrong - **Rolling with an additional batch** uses *new* instances temporarily, which does not strictly adhere to the requirement of **only using existing instances**.
D. Wrong - **Immutable** deployment launches a completely new Auto Scaling Group and then swaps the traffic, which does not use existing instances.

79.Explain
A. Wrong - Kinesis Streams guarantees order based on the time the record was written (FIFO), not LIFO.
B. Wrong - Kinesis guarantees order **within a shard**, but not across the entire stream (which is composed of multiple shards).
C. Correct - **Amazon Kinesis Streams** guarantees that records within a **single shard** are processed in the **exact order** they were received, following a **FIFO (First-In, First-Out) method**. However, since a stream is composed of multiple shards (4 in this case), and records may be distributed across them, there is **no guarantee of ordering across different shards**.
D. Wrong - The developer cannot select the order; it is guaranteed FIFO within a shard. `GetRecords` is the API, not the ordering mechanism.

80.Explain
A. Wrong - Using Lambda to send notifications is a reactive measure after the security breach has already occurred (an unencrypted object was uploaded). The policy requires ensuring compliance proactively.
B. Correct - The most effective way to **ensure compliance** (proactively prevent unencrypted uploads) is to configure an **Amazon S3 Bucket Policy** that uses the condition key `s3:x-amz-server-side-encryption` to **deny** the `s3:PutObject` action if the object is *not* encrypted. This ensures all data written to the bucket is encrypted at the point of ingestion.
C. Wrong - CloudWatch Events (now EventBridge) is designed to respond to events; it is a reactive measure, not a proactive gate on the upload process.
D. Wrong - Denying objects that *contain* the header would force objects to be unencrypted, which is the opposite of the requirement.

81.Explain
A. Correct - For **Amazon SQS FIFO (First-In, First-Out) queues**, order is guaranteed **only for messages that share the same MessageGroupId**. To ensure that **each sender's messages** are processed sequentially in the order they were sent, the developer must configure **each independent sender** to use a **unique MessageGroupId** when sending messages.
B. Wrong - `MessageDeduplicationIds` are used to prevent duplicate messages, not to enforce ordering.
C. Wrong - Configuring each message with a unique `MessageGroupId` would result in no guaranteed ordering, as each message would be treated as belonging to a separate sequence.
D. Wrong - `ContentBasedDeduplication` is used to prevent duplicate messages based on content, not to enforce ordering.

82.Explain
A. Wrong - AWS KMS is for encryption key management, not user authentication.
B. Correct - **Amazon Cognito** is the service purpose-built for authentication and authorization in web and mobile applications. It handles user sign-up/sign-in, works across **mobile, desktop, and tablets**, and its **Cognito Sync** feature can be used to **synchronize user preferences** across devices/platforms.
C. Wrong - AWS Directory Service is for managing enterprise directories (Active Directory), not for consumer-facing mobile/web authentication.
D. Wrong - AWS IAM is for managing access to AWS resources for internal users/roles, not for customer-facing application authentication.

83.Explain
A. Wrong - Tags are used for resource organization and cost allocation, not for passing runtime configuration to a function.
B. Wrong - Hardcoding resources is the worst practice, as it is inflexible, breaks the principle of environment separation, and requires code changes for every deployment.
C. Correct - The standard and most robust way to provide environment-specific configuration (like database endpoints, table names, API keys) to an AWS Lambda function is by using **Environment Variables**. These variables are configured per function version/alias/environment and are injected into the function's runtime environment, allowing the function code to read them and dynamically use the resources for the **current environment**.
D. Wrong - Using separate functions for development and production is unnecessary and violates the principle of using a single codebase for all environments.

84.Explain
A. Wrong - Amazon Cognito is for user authentication in web/mobile apps, not for temporary access between two internal AWS accounts.
B. Wrong - Creating a dedicated IAM access key is **not secure** because it involves distributing **long-lived credentials**, and sending it by mail is extremely insecure.
C. Correct - The **MOST secure** method for cross-account access is to establish a **cross-account access role** (the "target" role) in the second account, granting the calling entity's role in the first account (`Account-A`) permission to assume it. The developer then uses the **`sts:AssumeRole` API** to obtain **short-lived, temporary credentials** associated with that target role.
D. Wrong - Establishing trust and adding an SSH key is for secure shell access to an EC2 instance, not for programmatic access to AWS resources via the API.

85.Explain
A. Wrong - The X-Ray SDK is for instrumenting the application code, not for automatically performing annotation after the fact. The X-Ray **daemon** is necessary to forward the data.
B. Correct - To use AWS X-Ray on EC2:
    1. The application code must be **instrumented** using the **X-Ray SDK** to create segments and subsegments (timing calls, adding metadata).
    2. The **X-Ray daemon** must be **installed** and running on the EC2 instance. The daemon listens for and collects the segment data produced by the SDK and securely forwards it to the X-Ray service.
C. Wrong - The X-Ray daemon forwards data to the X-Ray service, not CloudWatch Events.
D. Wrong - The **X-Ray daemon** is missing from this step, and the SDK alone is not sufficient to upload the trace data to the X-Ray service.

86.Explain
A. Wrong - Putting credentials in a private repository requires the EC2 instance to be able to access the repository and manage the secret, which is less secure than using IAM roles.
B. Wrong - Injecting user credentials into instance user data exposes the long-lived credentials in plaintext during instance startup. This is insecure.
C. Wrong - CloudWatch metric policies are not the correct way to grant access to an EC2 instance; IAM roles are the correct mechanism.
D. Correct - The **MOST secure** way for an application running on an EC2 instance to access AWS services is to use **IAM Roles for EC2**. By creating an **IAM role** with the required `PutMetricData` permission and associating it with the instance via the **launch configuration**, the application automatically receives **temporary credentials** through the Instance Metadata Service. This eliminates the need to manage, store, or rotate long-lived credentials.

87.Explain
A. Wrong - `starRating` is limited to 5 distinct values (1-5). Using it as a Partition Key would lead to **five hot partitions**, resulting in poor performance, as the data and request traffic would be heavily concentrated on only five internal storage locations.
B. Correct - **`reviewID`** is a 16-digit UUID, which by nature is a globally **unique and highly random value**. Using a highly random value as the Partition Key ensures that the hundreds of millions of product reviews and the high volume of incoming requests are distributed **uniformly** across the maximum number of internal partitions in the DynamoDB table. This even distribution results in the **MOST consistent and optimal performance** (avoiding hot keys).
C. Wrong - `comment` is a free-form string and would likely not be used as a key.
D. Wrong - `productID` is likely to be reviewed many times. A few popular products would become **hot partitions**, leading to performance bottlenecks when many users review or look up reviews for those specific products.

88.Explain
A. Wrong - IAM policy conditions are used to specify *when* a policy is in effect (e.g., source IP, time of day), not to dynamically insert a username into the Resource ARN.
B. Wrong - The principal is the entity (user, role, service) that is *allowed* or *denied* access, not the mechanism for making the Resource ARN dynamic.
C. Correct - **IAM policy variables** (specifically, **`aws:username`**) are the correct approach. The generic policy snippet should use the variable: `"arn:aws:s3:::company-name/home/${aws:username}/*"`. When a team member assumes the role or is authenticated, AWS automatically substitutes the variable with their unique username, making the policy dynamic and reusable for all team members.
D. Wrong - The IAM policy resource defines *what* the policy applies to. The goal is to make the definition of the resource dynamic, not to simply state that a resource is being defined.

89.Explain
A. Wrong - SSE with Amazon S3 (SSE-S3) uses AWS-managed keys, but the customer has no control over the master key itself.
B. Correct - **Server-Side Encryption with AWS Key Management Service (SSE-KMS)** uses keys stored within the AWS KMS service. This service is **AWS-managed**, but the customer retains full control over the **Customer Master Key (CMK)**, including the key policy, rotation schedule, and audit trail via CloudTrail, thus meeting both requirements.
C. Wrong - Client-side encryption requires the customer to manage the encryption process and keys entirely within their application, which violates the requirement to use an **AWS managed service**.
D. Wrong - AWS IAM roles and policies manage permissions and access control, not the master encryption keys themselves.

90.Explain
A. Wrong - Retrieving the IAM group does not verify the *effective permissions* of the EC2 instance's role.
B. Wrong - EC2 metadata provides the attached role and temporary credentials, but it does not list the inline IAM policies on the role itself.
C. Wrong - Requesting a token and performing a `describe` action would use the credentials but does not provide a **dry-run** verification of the policy itself.
D. Correct - Many AWS API calls, including Kinesis's `GetRecords`, support a **`--dry-run`** argument in the CLI or a similar parameter in the SDKs. Using this flag attempts to perform the action and checks the IAM permissions *without* actually consuming resources or executing the action, providing a direct verification of access.
E. Correct - The **IAM Policy Simulator** is a web-based tool that allows a developer to select an IAM role (like the one attached to the EC2 instance), choose a service (Kinesis) and an action (`kinesis:GetRecords`), and verify whether the existing policy grants or denies the required access, making it a robust verification method.

91.Explain
A. Correct - **AWS CodeCommit** is the ideal source code repository for a CI solution on AWS. **CodePipeline** automates the workflow, including triggering on commits and running **unit tests (using CodeBuild)**. **Amazon SNS** is the standard AWS service for pushing **notifications** (e.g., email, SMS) when a pipeline stage (like unit testing) **fails**, meeting all requirements.
B. Wrong - Using GitHub is possible, but CodeCommit is a better native fit. More importantly, using **Amazon SES** is less standard for pipeline failure notifications than **Amazon SNS**.
C. Wrong - CloudWatch can monitor the pipeline, but **SNS** is the service used by CodePipeline for direct failure notifications.
D. Wrong - CloudWatch can monitor the pipeline, but **SNS** is the service used by CodePipeline for direct failure notifications.

92.Explain
A. Correct - The default `VisibilityTimeout` is 30 seconds, but the processing takes 40 seconds. The **BEST** way to prevent another instance from retrieving the message is to **first increase the `VisibilityTimeout`** using the **`ChangeMessageVisibility` API** to a value greater than 40 seconds. Once processing is complete, the instance must then call the **`DeleteMessage` API** to permanently remove the message from the queue.
B. Wrong - You cannot delete a message that is currently being processed without extending the timeout first, and `DeleteQueue` removes the entire queue.
C. Wrong - Decreasing the timeout value would guarantee the message becomes visible to other instances *sooner*, causing duplicate processing.
D. Wrong - There is no `DeleteMessageVisibility` API call.

93.Explain
A. Wrong - Storing session data in DynamoDB and sending codes via SNS requires the developer to build all the complex MFA logic, session management, and UI flows from scratch.
B. Correct - **Amazon Cognito** provides built-in support for **Multi-Factor Authentication (MFA)** within its User Pools feature. It can handle sending SMS codes, managing recovery options, and integrating the MFA flow seamlessly into the user sign-up and sign-in protocol, making it the simplest and most complete solution.
C. Wrong - AWS Directory Service provides enterprise directory services, not customer-facing MFA for mobile apps.
D. Wrong - AWS IAM with MFA enabled is for securing access to the AWS console and API for AWS users/roles, not for customer-facing application logins.

94.Explain
A. Correct - Read throughput is calculated by dividing the provisioned Read Capacity Units (RCUs) by the RCU cost per unit of data.
* **Eventually consistent reads** cost **0.5 RCU** per 4KB read.
* **Strongly consistent reads** cost **1 RCU** per 4KB read.
The capacity is 5 RCUs.
* Option A (Eventually consistent, 4KB): $5 \text{ RCU} / 0.5 \text{ RCU/read} = \mathbf{10 \text{ reads/sec}}$.
* Option B (Strongly consistent, 4KB): $5 \text{ RCU} / 1 \text{ RCU/read} = \mathbf{5 \text{ reads/sec}}$.
* Options C/D have 15 RCUs, which is not what the table has (5 RCUs). Assuming the question means 5 RCUs: 1KB items consume 1/4 of an RCU/WCU (but are still counted as a full unit if using strongly consistent reads, or 0.5 if eventually consistent reads).
**Eventually consistent reads** always provide the **highest throughput** for a given RCU provisioning because they cost half as much (0.5 RCU/read).

95.Explain
A. Wrong - CSS files (100KB) are small. Versioning might add storage, but CSS files alone cannot result in 50 GB of growth in a few days.
B. Wrong - S3 replication copies the 100KB of files to another region, resulting in 200KB of total storage, not 50 GB.
C. Correct - **Server access logging** creates a new log object in the target bucket **for every access request** (GET, PUT, etc.). If the target bucket is set to log to itself (`s3://mycoolapp/logs` inside `s3://mycoolapp`), every log file creation (PUT request) generates *another* access log entry, which in turn generates *another* log file, leading to an **exponential log growth loop**. This is the **MOST likely cause** of the massive, rapid storage increase.
D. Wrong - Lifecycle policies are for *managing* existing data, not for causing rapid, exponential growth.

96.Explain
A. Correct - **IAM Roles for ECS Tasks** is the best practice for granting permissions to applications running in containers on ECS/Fargate. You create an IAM role with the specific permissions (e.g., DynamoDB access) and link it directly to the **Task Definition**. The container application then automatically assumes this role using temporary credentials provided by ECS, which is the **MOST secure** and standard authentication method in a production ECS environment.
B. Wrong - Refactoring the application to assume a role based on the *instance* role is the less secure, legacy method. IAM Roles for Tasks is the modern standard.
C. Wrong - Storing credentials as environment variables or in a configuration file (D) is highly insecure, as it uses **long-lived access keys** that need to be managed and rotated manually.

97.Explain
A. Wrong - Modifying the `buildspec.yml` only helps with future builds; the developer needs to diagnose the *current* failure.
B. Wrong - X-Ray is for application tracing, not for debugging compilation failures in CodeBuild.
C. Correct - **AWS CodeBuild** captures all output (stdout and stderr) from every command executed in the `buildspec.yml` and stores them in **CloudWatch Logs**. The **MOST direct way** to identify the failure cause is to check the **Build Logs** associated with the last failed build attempt in the CodeBuild console's project history. The logs will point to the exact command and error message that caused the compilation to fail.
D. Wrong - Manually re-running the build locally is time-consuming, requires replicating the environment, and is not the official way to debug a CodeBuild failure.

98.Explain
A. Wrong - The application must be stopped before installation begins.
B. Correct - For in-place deployments, AWS CodeDeploy follows a fixed lifecycle to minimize conflicts and ensure proper cleanup/setup:
    1. **Application Stop**: Stop the running application instance.
    2. **Before Install**: Clean up files, run pre-installation setup.
    3. **After Install**: Run post-installation steps (e.g., dependency installation).
    4. **Application Start**: Start the new version of the application.
    (Note: The `ValidateService` hook typically runs after `Application Start`.)
C. Wrong - `ValidateService` runs after `Application Start`.
D. Wrong - `ValidateService` runs after `Application Start`.

100.Explain
A. Wrong - Storing secrets in S3 requires setting up KMS, writing application logic to generate and manage pre-signed URLs, and handling the file download, which is complex and requires significant administrative effort.
B. Wrong - Instance metadata is not designed for storing application secrets and should not be used for this purpose due to security concerns (it's accessible via a local HTTP endpoint).
C. Wrong - Using client-side encryption with DynamoDB requires the developer to manage the encryption library and code the retrieval/decryption logic, which is high effort.
D. Correct - **AWS Systems Manager (SSM) Parameter Store** is the purpose-built, highly secure, and managed service for storing configuration data and secrets (like database passwords). By configuring the EC2 instance's **IAM role** to have `ssm:GetParameter` permissions, the application can **programmatically access the encrypted secrets** with minimal code and the **LEAST administrative effort**, as AWS handles the encryption (using KMS) and access control.

101.Explain
A. Wrong - The Elastic Load Balancer (ELB) handles HTTP/HTTPS traffic to the application, not the direct S3 API calls.
B. Wrong - Application logs might show that the application *attempted* the request and received the error, but they won't confirm *why* the bucket doesn't exist (i.e., whether it was deleted).
C. Wrong - AWS X-Ray traces API calls but does not specifically track administrative actions like resource deletion.
D. Correct - **AWS CloudTrail** is the service that records all API calls made against your AWS account, including administrative actions. The error "The specified bucket does not exist" suggests a resource was deleted. The **BEST place** to find evidence of a **`DeleteBucket`** API call (who made it and when) is the **CloudTrail event history**.

102.Explain
A. Wrong - Specifying credentials as parameters for *each* command is impractical, time-consuming, and highly insecure.
B. Correct - The standard and recommended method for configuring the AWS CLI for a developer on a local machine is to run the **`aws configure`** command. This command prompts the user to enter their **IAM Access Key ID and Secret Access Key**. The CLI then stores these credentials locally in a configuration file (`~/.aws/credentials`), allowing the CLI to automatically use the developer's permissions for all subsequent commands.
C. Wrong - The AWS CLI uses IAM access keys and secret keys for authentication, not usernames and passwords.
D. Wrong - You can specify an IAM role to assume, but to start, the CLI needs the user's IAM credentials to be configured.

103.Explain
A. Correct - For event sources like **S3 Event Notifications** (which invoke the function asynchronously), **AWS Lambda** is designed to **scale out rapidly and automatically**. It creates a new execution environment (concurrent invocation) for **each incoming event** (or batch of events from other sources). Since processing each image takes less than a second, Lambda will create many concurrent execution environments to handle the additional traffic simultaneously.
B. Wrong - Lambda only handles requests sequentially if the source is configured to guarantee order (like an SQS FIFO queue or a Kinesis shard) or if the concurrency limit is reached.
C. Wrong - S3 Event Notifications trigger one execution per object (or notification); Lambda does not arbitrarily process multiple images in a single execution unless the event source is specifically configured to batch records.
D. Wrong - Lambda performance is scaled by increasing the **allocated memory**, not by adding more compute to each execution automatically in response to traffic.

104.Explain
A. Wrong - Global Secondary Indexes (GSIs) help with query flexibility but do not reduce the fundamental data retrieval latency from the underlying database storage.
B. Wrong - Storing trading data in S3 is for archival/analytics; it is not a low-latency, transactional data store.
C. Wrong - Retries only handle throttling errors; they do not reduce the read latency, which is the core issue.
D. Correct - To meet **sub-millisecond latency** requirements for read-heavy workloads like a trading application and **reduce over-provisioning costs**, the **DynamoDB Accelerator (DAX)** is the purpose-built service. DAX is a fully managed, in-memory cache that sits in front of DynamoDB. It caches the trading data, serving reads with microsecond latency and significantly **reducing the load on the underlying DynamoDB table**. This eliminates the need for massive over-provisioning and reduces costs.

105.Explain
A. Wrong - Even without explicit log statements, the Lambda service itself generates start/end/billing log entries. The absence of *all* log data indicates a more fundamental issue.
B. Wrong - CloudWatch Logs is the *destination* for Lambda logs, not a source trigger.
C. Correct - For a Lambda function to successfully write its execution logs (including the automatic start/end messages) to CloudWatch Logs, its associated **Execution Role** must have the necessary **IAM permissions** (`logs:CreateLogGroup`, `logs:CreateLogStream`, and `logs:PutLogEvents`). If these permissions are missing, the execution will succeed, but the logs will be silently dropped, as seen in this situation.
D. Wrong - If a log group does not exist, the Lambda service will attempt to create it, provided the execution role has the correct permissions.

106.Explain
A. Wrong - Even if the developer lacks view access, the traces should still be recorded by X-Ray.
B. Correct - When deploying an application instrumented with the X-Ray SDK onto an **EC2 instance**, the **X-Ray daemon** must be **installed and running** on that instance. The daemon is responsible for **collecting the trace segments** generated by the application and forwarding them to the X-Ray service endpoint. If the daemon is not installed, the application successfully generates trace data but has no mechanism to upload it.
E. Correct - The **EC2 Instance Role** (or the Task Role for ECS) is used by the X-Ray daemon to authenticate and authorize the upload of trace data. The daemon needs **`xray:PutTraceSegments`** (to upload data) and **`xray:PutTelemetryRecords`** (to report its health). If these permissions are missing from the instance role, the daemon will not be able to upload the traces to the X-Ray service.
(D is wrong because it lists permissions for *reading* traces, not *uploading* them.)

107.Explain
A. Wrong - A custom DynamoDB table would require building the entire identity system from scratch and doesn't inherently handle federation or multiple devices securely.
B. Wrong - IAM access key IDs are for programmatic access to AWS, not for application user identification, and are not designed to be exposed to users.
C. Correct - **Amazon Cognito Identity Pools** (Federated Identities) is the service for assigning unique identities to application users. By implementing **developer-authenticated identities**, the developer can use their own backend system to validate the user and then exchange that validation for a unique, consistent **Cognito Identity ID** that remains the same regardless of which device the user accesses the application from. This ID can then be used to get temporary AWS credentials for accessing resources.
D. Wrong - IAM users and roles are for internal AWS account access, not for managing application users.

108.Explain
A. Wrong - `get-template` is for downloading, and `execute-change-set` is for running a prepared change set; this sequence skips packaging and creation.
B. Wrong - `validate-template` is for checking syntax, and `create-change-set` is for previewing changes; this sequence does not deploy the application.
C. Correct - When deploying a serverless application defined by a **SAM template** (`Transform: AWS::Serverless-2016-10-31`), the process is:
    1. **`aws cloudformation package`**: This command **uploads local artifacts** (like Lambda code) to an S3 bucket and **produces a new, packaged CloudFormation template** with S3 links.
    2. **`aws cloudformation deploy`**: This command then takes the packaged template, automatically creates a Change Set, and executes it, performing the full deployment of the serverless stack.
D. Wrong - `create-stack` and `update-stack` are for manual/classic CloudFormation deployments; the `deploy` command is the simplified, single command used for SAM/serverless applications.

109.Explain
A. Wrong - An inline policy is just a different way to attach a policy; it would still be overridden by the environment variables.
B. Correct - The AWS CLI's **credential provider chain** checks for credentials in a specific order. It checks **environment variables** (`AWS_ACCESS_KEY_ID`, etc.) *before* checking the **EC2 instance metadata service** (where the IAM role credentials are provided). Since the old, unrestricted access keys are still present in the environment variables, the AWS CLI uses those long-lived keys first, bypassing the new, more restrictive IAM role policy.
C. Wrong - The CLI is likely not corrupt; the issue is the order of credential precedence.
D. Wrong - The credential provider checks for environment variables *first*, which is why the old credentials are still being used.

110.Explain
A. Correct - **Amazon S3 overwrite PUTS are eventually consistent**. When an object is overwritten (PUT), the change is not instantly reflected across all S3 storage nodes. If an application immediately tries to read the object after the overwrite, there is a short window where the read request might be routed to a storage node that has not yet received the update, thus retrieving the **old version of the object**.
B. Wrong - Metadata is not required to determine the latest version.
C. Wrong - All S3 **new object PUTS** are read-after-write consistent, but **overwrite PUTS** are eventually consistent.
D. Wrong - S3 handles versioning automatically; the application doesn't need to specify the latest version for a simple read unless S3 versioning is explicitly enabled (which is not mentioned).

111.Explain
A. Wrong - `KMS Encrypt` can only encrypt data up to 4 KB directly. Video files are much larger.
B. Wrong - Generating a key with a cryptography library is not wrong, but it fails to meet the implicit security requirement of using an **AWS managed service (KMS)** to protect the key itself.
C. Correct - For large file encryption (like video files) while leveraging KMS, the developer must use **Envelope Encryption**:
    1. Call the **`KMS GenerateDataKey` API** to obtain a plaintext data key and its encrypted copy (encrypted by the CMK).
    2. Use the **plaintext data key** with a cryptography library (like AES) to rapidly **encrypt the large video file**.
    3. **Immediately destroy the plaintext data key** from memory.
    4. **Store the encrypted video file** along with the **encrypted data key**. This is the standard, secure, and performant method for large-scale data encryption with KMS.
D. Wrong - This approach uses SSE-KMS, but the requirement is to encrypt the data **within the application** *prior* to storage (Client-Side Envelope Encryption).

112.Explain
A. Wrong - CloudTrail logs API activity, but not the asynchronous event processing failures within Lambda.
B. Correct - When a Lambda function fails after the configured retries for an **asynchronous invocation**, the event is discarded by default. To **troubleshoot the failure**, the developer should configure a **Dead Letter Queue (DLQ)**, typically an **Amazon SQS queue**. When the function fails its retries, the event context and payload are delivered to the DLQ, allowing the developer to inspect the failed events, replay them, and determine the root cause.
C. Wrong - Amazon Simple Workflow Service (SWF) is an orchestration service; it is not used as a DLQ.
D. Wrong - AWS Config is an auditing service; it is not used as a DLQ.

113.Explain
A. Wrong - Creating a new stage and sharing a new URL for every customer choosing a larger package is high administrative overhead.
B. Wrong - Using CloudWatch metrics and a Lambda function to dynamically deny requests is complex to implement, prone to latency/errors, and involves high management overhead for every package change.
C. Wrong - Using CloudWatch alarms to deny requests is a poor use of the alarm system (alarms are for monitoring, not enforcement) and still requires creating user-specific alarms, which is high overhead.
D. Correct - **API Gateway Usage Plans** are the purpose-built feature for managing request quotas and throttling. By setting up a **default Usage Plan** and associating it with the stage, the developer handles most users. To offer larger packages, the developer simply creates **custom Usage Plans** with higher limits and associates the **API Key** of the registered developer with the appropriate custom plan. This solution is fully managed and requires the **LEAST amount of administrative overhead**.

114.Explain
A. Wrong - SQS is an asynchronous queue service; it manages the sequence of events but cannot orchestrate parallel or conditional steps like a workflow engine.
B. Wrong - AWS Step Functions activities are used for coordinating tasks performed by workers outside of Step Functions; Lambda integration is typically done directly with the function.
C. Wrong - SNS is a pub/sub notification service; it triggers parallel subscribers but cannot enforce a specific sequential workflow.
D. Correct - **AWS Step Functions state machine** is the designated **serverless orchestration service**. It allows the developer to define a workflow that precisely dictates the **sequence (sequential and parallel branches)** in which the individual Lambda functions are executed, and API Gateway can be configured to start the state machine.

115.Explain
A. Wrong - `ConsistentRead` ensures the read operation returns the most recent write, but it doesn't provide multi-item, all-or-nothing transactional guarantees.
B. Wrong - ElastiCache (Memcached) is a caching layer, not a transactional database.
C. Correct - **Amazon Aurora MySQL** is a relational database that fully supports **ACID transactions**. Wrapping the updates for both users' records within a `transaction block` (BEGIN, COMMIT/ROLLBACK) ensures atomicity.
D. Correct - **Amazon DynamoDB** provides **ACID transactional capabilities** for multiple items (up to 25) within or across tables using the dedicated **`TransactWriteItems`** and **`TransactGetItems`** operations, meeting the all-or-nothing update requirement.
E. Wrong - Amazon Redshift is an analytical data warehouse, not intended for high-velocity, transactional item updates.

116.Explain
A. Correct - The standard way to interact with a Git repository is using the **Git CLI**. The Lambda function's runtime environment has limited writable space (the `/tmp` directory). The developer can include the Git CLI in the deployment package/layer, **clone the repository** to `/tmp`, add the new file, commit, and **push the change** back to CodeCommit using the permissions granted by the Lambda Execution Role.
B. Wrong - CodeCommit API is not designed to accept files via cURL.
C. Wrong - Using the AWS SDK's `put_file` method is a programmatic way to add a single file, but it doesn't utilize standard Git operations like clone, commit, and push, which are often necessary for repository management.
D. Wrong - Using S3 events and Step Functions adds unnecessary complexity for a simple file check-in.

117.Explain
A. Wrong - Environment variables can be viewed or leaked, exposing long-lived credentials.
B. Wrong - Credentials files store long-lived keys locally and are vulnerable if the host is compromised.
C. Correct - **Instance profile credentials** are temporary credentials dynamically provided by the **IAM Role attached to the EC2 instance** through the Instance Metadata Service. This is the **most secure method** as it avoids storing long-lived access keys on the instance.
D. Wrong - Command line options expose credentials to shell history and other users on the system.

118.Explain
A. Wrong - Storing and managing static access keys in application code for 25,000+ users is highly insecure and unscalable.
B. Wrong - Using S3 bucket policies for every individual IAM user is unmanageable at scale (25,000+ users).
C. Correct - **Amazon Cognito Identity Pools (Federated Identities)** are designed for this scenario. They can automatically grant access to S3 based on user type using two separate roles: an **Authenticated Role** (for registered users) and an **Unauthenticated Role** (for guest users).
E. Correct - The application can use **AWS Security Token Service (AWS STS) `AssumeRole`** to obtain temporary credentials for a pre-defined set of roles (e.g., `RegisteredUserRole`, `GuestUserRole`) based on its own authentication logic. This leverages the security of IAM and STS's temporary credentials.

119.Explain
A. Wrong - VPC is a networking concept, not an authentication or authorization mechanism.
B. Wrong - **Cognito User Pools** manages user directories and would require **mirroring** employee information, which violates the requirement.
C. Correct - **Amazon Cognito Identity Pool** allows **federation with the SAML provider** without needing to store or mirror employee data on AWS. After federation, Cognito issues a unique **Identity ID (`cognito-identity.amazonaws.com:sub`)**. The developer can use this variable as an **IAM condition key** in the granted IAM role policy (e.g., `Allow S3 access to bucket/data/${cognito-identity.amazonaws.com:sub}/*`), ensuring each employee can access **only their own data**.
D. Wrong - Creating a unique IAM role for 25,000 employees is complex and unmanageable.

120.Explain
A. Wrong - Compressing and uploading are parts of the packaging step, not a separate preliminary step.
B. Wrong - Testing and tracing are part of the deployment validation process, not the preparation step.
C. Correct - The **AWS SAM CLI** requires the artifacts (like Lambda code) to be uploaded to an S3 bucket before deployment. The **`sam package`** command (or `aws cloudformation package`) bundles local artifacts, uploads them to S3, and creates a new, deployment-ready template with the S3 links. This step **must** be completed prior to running `sam deploy`.
D. Wrong - `eb create` is an Elastic Beanstalk command, not part of the SAM CLI workflow.

121.Explain
A. Wrong - SSE-S3 uses keys owned and managed by Amazon.
B. Wrong - SSE-KMS uses keys managed by AWS KMS (though customers manage key usage policies).
C. Wrong - Client-side encryption is handled by the application, but the requirement states encryption is handled by S3 (server-side).
D. Correct - **Server-Side Encryption with Customer-Provided Keys (SSE-C)** is the mechanism where S3 handles the encryption process (server-side) but the **customer provides the encryption key** to S3 with every request. This key is used for cryptographic operations but is **managed and stored by the customer** (on-premises).

122.Explain
A. Wrong - S3 event directly triggering Lambda can lead to massive concurrent executions and potential throttling/overload of the backend processing service during volume spikes.
B. Correct - **S3 Event -> SQS Queue -> Lambda.**
    1. The **Amazon SQS queue** acts as a **buffer (shock absorber)**, absorbing the flood of S3 upload events during the simultaneous event.
    2. SQS **smooths out temporary volume spikes**, allowing the Lambda function (the backend service) to process items at a steady, controlled pace (controlled by the SQS polling mechanism), making the solution the **MOST resilient** against sudden, high-volume traffic.
C. Wrong - API Gateway is for synchronous API calls and has throttling limits; it is not suitable for handling massive asynchronous uploads.
D. Wrong - Step Functions provides orchestration but does not smooth out traffic spikes; it would simply start tasks at the same high rate as the S3 events.

123.Explain
A. Wrong - **Pod specification** is a Kubernetes/EKS concept, not the term used in Amazon ECS.
B. Wrong - **Two task definitions** would run the containers in separate execution environments, preventing them from easily sharing a volume.
C. Correct - In Amazon ECS, the application and its sidecar (log/metrics collector) must be defined within a **single Task Definition**. By defining both containers and a **shared volume** (e.g., an empty directory) within that task, both containers can **mount that volume** at runtime to exchange data, such as logs, metrics, or configuration files.
D. Wrong - **Pod specification** is a Kubernetes/EKS concept. Mounting a **persistent volume** is usually for long-term data storage, not for temporary inter-container communication like log collection.

124.Explain
A. Correct - **Amazon CloudWatch** is the primary monitoring service for AWS. It automatically collects the **`CPUUtilization`** metric for EC2 instances. Creating a **CloudWatch alarm** with a threshold of 80% and configuring it to send a notification to an **Amazon SNS topic** is the standard, managed, and most efficient solution to meet this requirement.
B. Wrong - **AWS CloudTrail** records API calls and account activity, not performance metrics like CPU utilization.
C. Wrong - Creating a cron job is a manual, high-overhead solution that requires managing custom logic and does not scale well compared to CloudWatch.
D. Wrong - AWS CloudTrail does not contain the `CPUUtilization` metric; that metric is found in CloudWatch.

125.Explain
A. Wrong - An IAM role grants permissions to *access AWS services*, not the database credentials (username/password) required to open an SQL Server connection.
B. Correct - **AWS Secrets Manager** is the service specifically designed to store, manage, and retrieve application secrets, including database credentials. It also provides built-in integration for **automatically rotating** the credentials for Amazon RDS databases, making it the **MOST secure** and automated solution.
C. Wrong - Storing credentials in S3, even encrypted, is less secure than a managed secret store, and this approach does not facilitate automatic rotation.
D. Wrong - Storing credentials directly in source code is a major security vulnerability.

126.Explain
A. Wrong - The **All at once** policy causes **downtime** because all instances are updated simultaneously, which is unacceptable when aiming for the **LEAST amount of downtime**.
B. Wrong - **Rolling with additional batch** does not guarantee a full cutover simultaneously and does not allow for a quick rollback to the exact previous environment state.
C. Correct - **Blue/Green Deployment** (deploying the new version in a new environment and then **swapping environment URLs**) is the ideal strategy for a full cutover with incompatible versions. It provides **near-zero downtime** (only the DNS swap time) and the ability to instantly **roll back** by swapping the URLs back to the original, running environment if the new version fails.
D. Wrong - **Rolling deployment** updates instances in batches, which maintains service availability but is slower and can lead to issues with incompatible versions (split traffic between old and new code).

127.Explain
A. Wrong - Copying documents consumes time, doubles storage, and is not an efficient way to manage a short expiration time.
B. Correct - A **presigned S3 URL** is a time-limited URL that grants temporary permission to access a specific object in a private bucket. By creating it with the **AWS SDK** and an **expiration time of 15 minutes**, the developer meets all requirements: secure, grants access to authenticated users (who trigger the creation), and is time-limited.
C. Wrong - SSE-KMS is an encryption method; it does not control user authorization or time limits for downloads.
D. Wrong - Manually modifying the S3 bucket policy and reverting the change is high-overhead, error-prone, and not scalable.

128.Explain
A. Correct - In AWS Step Functions' States Language, the **`ResultPath`** parameter in a **`Catch`** statement specifies where the error output should be placed in the state's input/output. If you set `ResultPath` to a new field (e.g., `"$.errorInfo"`), the original **state input is preserved**, and the error details are **added** to it at the specified path, thus ensuring the output contains both the original input and the error message.
B. Wrong - `InputPath` is used to filter the data *before* it's passed to the state's processing, not for preserving error details.
C. Wrong - `Retry` statements are used to attempt the task again upon failure; they do not control the state's output format.
D. Wrong - `OutputPath` filters the data *after* the state is processed. It's not used in a `Retry` statement to include the error, and setting it to `$` would pass through the current output, which is not guaranteed to contain the original input.

129.Explain
A. Wrong - Assigning an IAM role helps with authorization but doesn't resolve API call rate limiting.
B. Correct - The error **`RequestLimitExceeded`** (Code 503 Service Unavailable) indicates **throttling**. The standard and necessary fix is to **implement an exponential backoff algorithm**. This client-side strategy automatically increases the delay between retry attempts after throttling errors, ensuring the client doesn't overwhelm the API and allowing requests to eventually succeed.
C. Wrong - Network bandwidth is unrelated to API call rate limits enforced by the service.
D. Wrong - Software versions do not guarantee protection against throttling; the client logic must implement backoff.

130.Explain
A. Correct - To reference a resource value (like the dynamically generated S3 bucket name) from one CloudFormation stack in another stack, you must use **Cross-Stack References**. This requires adding an **`Export`** declaration to the **`Outputs`** section of the source template and using the intrinsic function **`Fn::ImportValue`** in the consuming template.
B. Wrong - `Exported: true` and `ImportResource` are not valid CloudFormation syntax for this purpose.
C. Wrong - Creating a custom resource is overly complex and unnecessary when a native CloudFormation solution exists.
D. Wrong - `Fn::Include` is used to embed template snippets, not to reference output values from a deployed, running stack.

131.Explain
A. Correct - The **`AfterInstall`** lifecycle event hook is executed **after** the application files have been downloaded (`DownloadBundle`) and copied to the instance's deployment location (`Install`). This is the ideal stage to run configuration scripts (like changing file permissions) **before** the application service is started (`ApplicationStart`).
B. Wrong - `DownloadBundle` is only for fetching the files from S3.
C. Wrong - `BeforeInstall` runs before the files are copied to their final location.
D. Wrong - `ValidateService` is for running health checks after the service is started.

132.Explain
A. Wrong - DynamoDB Streams provides a change log, which doesn't directly reduce read/write latency.
B. Correct - **Amazon DynamoDB Accelerator (DAX)** is a fully managed, in-memory cache service built specifically for DynamoDB. It is designed to reduce the response times for eventually consistent read operations from milliseconds to **microseconds**, significantly improving application performance.
C. Wrong - Global tables improve global availability and multi-region read latency, but not the fundamental read/write latency of the nearest region's table.
D. Wrong - Transactions provide ACID guarantees but can slightly increase operational latency compared to standard reads/writes.

133.Explain
A. Correct - The AWS CLI commands `aws cloudformation package` (to upload artifacts and create a deployment template) and `aws cloudformation deploy` (to deploy the stack) are the low-level, valid commands for deploying SAM applications.
B. Correct - The **AWS SAM CLI** provides the dedicated, simplified commands **`sam package`** (which wraps `aws cloudformation package`) and **`sam deploy`** (which wraps `aws cloudformation deploy`). This is the **recommended** way to automate SAM deployment.
C. Wrong - This sequence bypasses CloudFormation orchestration and is not the correct way to deploy a SAM template.
D. Wrong - `aws serverlessrepo create-application` is for publishing to a repository, not for deploying a local application.
E. Wrong - This sequence misses the crucial **packaging** step required for SAM templates to upload Lambda code to S3.

134.Explain
A. Correct - **Amazon Cognito User Pools** is the dedicated service for managing user sign-up, sign-in, and access control for mobile and web apps. Creating a user pool and users is the necessary foundation.
B. Wrong - While SNS is used for text codes, the developer should **enable MFA within Cognito** (Option C) to manage the entire process securely, rather than writing custom code using the SNS API.
C. Correct - Once the user pool is set up, the developer must **enable multi-factor authentication for the Amazon Cognito user pool** settings to enforce the MFA requirement during user sign-in. Cognito handles the complexities of sending and validating the codes.
D. Wrong - AWS IAM is for internal AWS resource access, not for application end-users.
E. Wrong - IAM MFA is for securing access to the AWS console/API by IAM users, not the mobile app's end-users.

135.Explain
A. Wrong - Setting `ECS_ENABLE_TASK_IAM_ROLE` to `false` disables the feature needed to grant different permissions to different tasks.
B. Wrong - Granting the **Instance Profile Role** broad access violates the principle of **least privilege** for the individual microservices.
C. Correct - **Task IAM Roles** (enabled by setting **`ECS_ENABLE_TASK_IAM_ROLE` to `true`**) allow a developer to assign a dedicated, fine-grained IAM role to **each individual ECS task**. This is the method for granting each microservice **the minimum privileges** it needs: Role A for Aurora read-only, Role B for DynamoDB read-only.
D. Wrong - Granting the Instance Profile Role broad access violates the principle of least privilege.

136.Explain
A. Wrong - Custom CloudWatch metrics provide aggregate timing, but lack the detailed, visualized timeline needed to isolate a bottleneck within specific function calls inside the code.
B. Wrong - X-Ray is the correct tool, but the results are analyzed in the **X-Ray console**, not the CloudWatch console.
C. Correct - **AWS X-Ray** is the purpose-built service for analyzing performance bottlenecks in distributed applications, including Lambda functions. By using the **AWS X-Ray SDK** to **write trace data from strategic places** in the Java code, the developer can view a detailed **trace timeline and service map** in the **X-Ray console** to pinpoint the exact segment or function call responsible for the latency.
D. Wrong - CloudWatch metrics and X-Ray analysis are separate; X-Ray data must be analyzed in the X-Ray console.

137.Explain
A. Correct - SQS costs are driven by the number of API calls, particularly `ReceiveMessage` calls made by the consumer (the EC2 instance). If messages are infrequent (one per minute), constantly short-polling is expensive. **Increasing the Amazon SQS queue polling timeout** (enabling **Long Polling**) reduces the number of `ReceiveMessage` API calls the application makes to receive the same number of messages, thus significantly **reducing SQS costs**.
B. Wrong - SQS is serverless and scales automatically; there is no manual "scaling down" to reduce costs.
C. Wrong - Configuring push delivery via SNS is a architectural change and SNS has its own costs; it doesn't solve the core issue of inefficient polling.
D. Wrong - FIFO queues are for message ordering guarantees; they do not inherently reduce polling costs.

138.Explain
A. Wrong - CloudTrail logs API activity and security events, not detailed end-to-end latency tracing of user requests.
B. Correct - **AWS X-Ray** is the service designed to trace requests end-to-end across interconnected services. By **enabling and configuring X-Ray tracing on both API Gateway and the Lambda function**, the developer gets a unified **service map and detailed trace timeline** that shows the time spent in each segment (API Gateway overhead, Lambda initialization, Lambda execution, DynamoDB call time), allowing them to quickly **identify performance bottlenecks**.
C. Wrong - Logs from separate services lack the consolidated, visual timeline necessary for end-to-end bottleneck analysis.
D. Wrong - VPC Flow Logs capture network traffic, which is not the correct tool for analyzing API and function execution latency.

139.Explain
A. Wrong - The explicit deny takes precedence over the implicit or explicit allow.
B. Wrong - The explicit deny takes precedence.
C. Wrong - The explicit deny takes precedence.
D. Correct - In IAM policy evaluation logic, an **Explicit Deny** in any policy takes **highest precedence** and **always overrides** any Allow statement. Since the IAM role attached to the EC2 instance includes an explicit deny for all S3 actions, this denial will override the full administrative access granted by the user's local credentials file. Therefore, the **EC2 instance will not be able to perform any S3 action**.

140.Explain
Answer A - wrong because total count not retain.
Answer B - wrong because disable not retain.
Answer C - wrong because age not retain.
Answer D - correct because Retention setting keeps bundle.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.as-versions.html

141.Explain
Answer A - correct because cache not invalidated after price update.
Answer B - wrong because write-through retrieves updated data automatically.
Answer C - wrong because read capacity does not affect data freshness.
Answer D - wrong because write capacity does not affect cache consistency.
link ref: https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Strategies.html

142.Explain
Answer A - wrong because KMS does not manage Git credentials.
Answer B - correct because Git credential helper uses AWS credential profile for HTTPS clone.
Answer C - wrong because ACM handles SSL/TLS, not repository authentication.
Answer D - wrong because CloudHSM not used for CodeCommit authentication.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-https-unixes.html

143.Explain
Answer A - wrong because X-Ray receives data directly, not from S3-triggered Lambda.
Answer B - wrong because CloudWatch cannot forward logs to X-Ray automatically.
Answer C - correct because Lambda execution role must have X-Ray permissions and tracing enabled.
Answer D - wrong because X-Ray daemon not needed for Lambda tracing.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html

144.Explain
Answer A - wrong because trust policy must allow EC2, not DynamoDB.
Answer B - correct because EC2 assumes the role, and iam:PassRole needed by developers.
Answer C - wrong because trust policy incorrectly allows DynamoDB.
Answer D - wrong because iam:GetRole alone not enough to launch instance with role.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

145.Explain
Answer A - correct because missing module must be packaged and uploaded in ZIP with code.
Answer B - wrong because uploading lib folder alone misses dependencies.
Answer C - wrong because installing modules via shell not supported in Lambda runtime.
Answer D - wrong because environment variable not fix missing module.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

146.Explain
Answer A - correct because Cognito identity pool exchanges JWT for temporary AWS credentials.
Answer B - wrong because EC2 instance profile not secure for web app users.
Answer C - wrong because hardcoding credentials is insecure.
Answer D - wrong because user pool JWT cannot access DynamoDB directly.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html

147.Explain
Answer A - wrong because OpsWorks not used for infrastructure versioning.
Answer B - wrong because CloudWatch cannot deploy infrastructure.
Answer C - wrong because Elastic Beanstalk not for IaC version control.
Answer D - correct because CloudFormation manages infrastructure as code with versioning via CodeCommit.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html

148.Explain
Answer A - wrong because service definition cannot include environment variables.
Answer B - correct because environment variables are defined in task definition.
Answer C - wrong because entryPoint defines container startup command.
Answer D - wrong because service definition does not hold environment parameters.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/taskdef-envfiles.html

149.Explain
Answer A - wrong because Server ID not suitable as sort key for time range queries.
Answer B - wrong because Redshift not ideal for Lambda-triggered events.
Answer C - correct because DynamoDB with TS-Server sort key supports time range queries.
Answer D - wrong because Redshift unsuitable for event-driven indexing.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-sort-keys.html

150.Explain
Answer A - correct because global secondary indexes optimize frequent queries on non-key attributes.
Answer B - wrong because local secondary indexes are limited to same partition key.
Answer C - wrong because global tables used for multi-region replication, not query speed.
Answer D - wrong because auto scaling affects throughput, not query optimization.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SecondaryIndexes.html

151.Explain
Answer A - wrong because CloudWatch alarm not needed for S3 uploads.
Answer B - correct because S3 event notification triggers Lambda directly with minimal cost and latency.
Answer C - wrong because scheduled event unnecessary.
Answer D - wrong because EC2 polling increases cost and latency.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/NotificationHowTo.html

152.Explain
Answer A - wrong because SSL certificates not restrict account-level access.
Answer B - correct because API Gateway resource policy restricts usage to specific AWS accounts.
Answer C - wrong because CORS only controls browser-origin access.
Answer D - wrong because usage plans limit throttle/quota, not access scope.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-resource-policies.html

153.Explain
Answer A - wrong because self-managed MongoDB increases maintenance.
Answer B - correct because Amazon DocumentDB supports MongoDB compatibility with minimal changes.
Answer C - wrong because API Gateway cannot translate MongoDB API calls.
Answer D - wrong because DynamoDB not MongoDB-compatible.
link ref: https://docs.aws.amazon.com/documentdb/latest/developerguide/mongo-apis.html

154.Explain
Answer A - wrong because SQS queue not for logging.
Answer B - wrong because CloudWatch Events cannot capture Lambda logs.
Answer C - correct because logging statements in code automatically sent to CloudWatch Logs.
Answer D - wrong because SNS topic not required for Lambda log delivery.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html

155.Explain
Answer A - correct because ConsistentRead=true ensures strong consistency in DynamoDB.
Answer B - wrong because DAX provides eventual consistency.
Answer C - wrong because UpdateTable does not control read consistency.
Answer D - wrong because GetShardIterator applies to Kinesis, not DynamoDB.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html

156.Explain
Answer A - wrong because RDS cannot stream data.
Answer B - wrong because Direct Connect not handle streaming data.
Answer C - correct because Kinesis Data Streams with Lambda provides scalable serverless data processing.
Answer D - wrong because EC2 script not serverless.
link ref: https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html

157.Explain
Answer A - wrong because DynamoDB migration unnecessary.
Answer B - correct because ElastiCache for Redis caches read-heavy data to reduce database load.
Answer C - wrong because EC2-based caching adds management overhead.
Answer D - wrong because DAX works only with DynamoDB, not RDS.
link ref: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html

158.Explain
Answer A - wrong because 10 reads of 10 KB each need 30 RCU for strong consistency.
Answer B - correct because strong reads (10×3 RCU) and transactional writes (2×20 WCU) = 30/40.
Answer C - wrong because provisioned mode required by user.
Answer D - wrong because overprovisioned and costly.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ProvisionedThroughput.html

159.Explain
Answer A - correct because Redis stores session data for shared state in containers.
Answer B - wrong because Redshift not for session management.
Answer C - wrong because NLB stickiness not persist sessions across containers.
Answer D - wrong because S3 not suitable for session storage.
link ref: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/BestPractices.html

160.Explain
Answer A - correct because adding read replicas improves read scalability and resiliency.
Answer B - wrong because Memcached lacks replication and persistence.
Answer C - wrong because Elasticsearch not a caching layer.
Answer D - wrong because vertical scaling does not add fault tolerance.
link ref: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Replication.html

161.Explain
Answer A - correct because AWS X-Ray traces requests across microservices and identifies performance bottlenecks.
Answer B - wrong because VPC Flow Logs track network traffic, not application trace data.
Answer C - wrong because GuardDuty detects threats, not performance issues.
Answer D - wrong because Macie classifies sensitive data, not application latency.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html

162.Explain
Answer A - wrong because creating a separate pipeline is inefficient.
Answer B - correct because CodeBuild buildspec can include unit test phase for CI/CD integration.
Answer C - wrong because CodeDeploy agent is for deployment, not testing.
Answer D - wrong because testing branch in CodeCommit does not automate unit tests.
link ref: https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html

163.Explain
Answer A - correct because DynamoDB supports key/value store, scalability, and eventual consistency.
Answer B - wrong because S3 does not support key/value queries.
Answer C - wrong because RDS lacks scalability for thousands of TBs.
Answer D - wrong because ElastiCache stores volatile data, not long-term data.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html

164.Explain
Answer A - wrong because user pool requires authentication.
Answer B - correct because identity pool with unauthenticated identities grants temporary AWS access.
Answer C - wrong because user pools handle authentication only.
Answer D - wrong because disabling authentication does not allow guest access.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/identity-pools.html

165.Explain
Answer A - wrong because CodeBuild compiles code, not stores it.
Answer B - wrong because S3 does not support versioned collaboration with code diff.
Answer C - correct because CodeCommit provides version control and long-term storage for code.
Answer D - wrong because Cloud9 is an IDE, not a repository.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html

166.Explain
Answer A - wrong because ChangeMessageVisibility controls message timeout.
Answer B - wrong because AddPermission grants queue access, not message batch size.
Answer C - correct because ReceiveMessage allows setting MaxNumberOfMessages > 1 for batch retrieval.
Answer D - wrong because SetQueueAttributes cannot set MaxNumberOfMessages.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_ReceiveMessage.html

167.Explain
Answer A - wrong because Lambda can be registered with ALB.
Answer B - wrong because both CLI and console support ALB target registration.
Answer C - correct because Lambda needs invoke permissions from ALB target group.
Answer D - wrong because cross-zone setting unrelated to Lambda invocation.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/lambda-functions.html

168.Explain
Answer A - wrong because throttling limits only request rate.
Answer B - correct because usage plans with API keys enforce SLA per user.
Answer C - wrong because Cognito does not handle API rate limits.
Answer D - wrong because default throttling is not SLA-based.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html

169.Explain
Answer A - wrong because Ref cannot import from another stack.
Answer B - correct because Fn::ImportValue imports exported VPC value from another template.
Answer C - wrong because DependsOn controls stack order, not data reference.
Answer D - wrong because Fn::GetAtt works only within same template.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-importvalue.html

170.Explain
Answer A - wrong because AppSync is for GraphQL, not authentication.
Answer B - correct because Cognito identity pools support SAML and social logins with AWS access.
Answer C - wrong because user pools handle authentication but not AWS resource access.
Answer D - wrong because Lambda@Edge customizes content delivery, not authentication.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html

171.Explain
Answer A - wrong because CLI supports custom metrics.
Answer B - correct because put-metric-data publishes metrics to CloudWatch before alarms.
Answer C - wrong because agent not required for custom metrics.
Answer D - wrong because instance type not relevant.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

172.Explain
Answer A - wrong because default EC2 metrics do not include custom app data.
Answer B - wrong because S3 files are not suitable for metric visualization.
Answer C - correct because publishing custom metrics to CloudWatch enables monitoring and graphs.
Answer D - wrong because CloudWatch cannot collect variables directly.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

173.Explain
Answer A - wrong because SES integration requires custom automation.
Answer B - wrong because tagging commits does not enforce approvals.
Answer C - wrong because CodeCommit lacks built-in approval mechanism.
Answer D - correct because CodePipeline supports manual approval action with SNS notification.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/approvals.html

174.Explain
Answer A - wrong because Lambda@Edge is for CloudFront, not API Gateway.
Answer B - correct because API Gateway integrates with Lambda for REST APIs.
Answer C - correct because GET method must be exposed in API Gateway.
Answer D - wrong because Lambda does not define HTTP methods.
Answer E - wrong because Route 53 handles DNS, not APIs.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html

175.Explain
Answer A - correct because Secrets Manager securely stores and rotates connection strings.
Answer B - wrong because IAM user cannot store database connection strings.
Answer C - wrong because KMS manages keys, not strings directly.
Answer D - wrong because Lambda layers store code, not configuration.
link ref: https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html

176.Explain
Answer A - wrong because CloudTrail adds unnecessary cost for S3 data events.
Answer B - wrong because expiring logs removes audit history.
Answer C - wrong because CloudTrail not required for object access logging.
Answer D - correct because server access logging with Glacier lifecycle is cost-effective.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerLogs.html

177.Explain
Answer A - wrong because SSE-S3 lacks key rotation control.
Answer B - correct because SSE-KMS allows key creation, rotation, and access control.
Answer C - wrong because Secrets Manager is not for S3 encryption.
Answer D - wrong because SSE-C requires external key management.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

178.Explain
Answer A - wrong because EBS volumes are instance-specific.
Answer B - correct because S3 provides centralized shared storage accessible to all instances.
Answer C - wrong because instance storage is ephemeral.
Answer D - wrong because synchronization adds latency and complexity.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html

179.Explain
Answer A - wrong because S3 CORS affects bucket requests only.
Answer B - correct because enabling CORS in API Gateway allows cross-origin requests.
Answer C - wrong because adding request headers alone doesn’t resolve CORS.
Answer D - wrong because missing headers come from API, not client.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html

180.Explain
Answer A - wrong because SSE-C keys not managed by AWS Security team.
Answer B - wrong because client master key management adds complexity.
Answer C - correct because client-side encryption with KMS-managed CMK meets control and compliance.
Answer D - wrong because SSE-S3 uses Amazon-managed keys, not Security team-managed keys.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingClientSideEncryption.html

181.Explain
Answer A - wrong because Auto Scaling not available for streams.
Answer B - wrong because delay does not fix throughput.
Answer C - correct because increasing shards increases capacity.
Answer D - wrong because shard iterator only retrieves data.
Answer E - correct because exponential backoff helps handle throttling.
link ref: https://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html

182.Explain
Answer A - wrong because console cannot enable encryption on existing log groups.
Answer B - wrong because create-log-group only works when creating new groups.
Answer C - wrong because KMS console cannot associate directly.
Answer D - correct because associate-kms-key encrypts existing log group data.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html

183.Explain
Answer A - wrong because embedding access keys in code is insecure.
Answer B - correct because IAM role grants secure temporary credentials.
Answer C - wrong because root user keys violate best practices.
Answer D - wrong because AdministratorAccess is excessive privilege.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

184.Explain
Answer A - wrong because rolling updates still lose session state.
Answer B - correct because ElastiCache externalizes session storage.
Answer C - wrong because sticky sessions only work per ALB node.
Answer D - wrong because multicast not supported in AWS network.
link ref: https://docs.aws.amazon.com/elasticache/latest/mem-ug/WhatIs.html

185.Explain
Answer A - wrong because CloudWatch Events not triggered directly by S3.
Answer B - correct because S3 can invoke Lambda to process new objects.
Answer C - wrong because Lambda cannot poll S3.
Answer D - wrong because cron job adds unnecessary delay.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-event-types-and-destinations.html

186.Explain
Answer A - wrong because CodeDeploy does not restore from S3 snapshots.
Answer B - wrong because that applies to blue/green deployments, not in-place.
Answer C - correct because CodeDeploy redeploys last successful revision.
Answer D - wrong because CodePipeline does not auto-promote failed builds.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/deployments-rollback-and-redeploy.html

187.Explain
Answer A - wrong because IAM role cannot grant bucket-to-bucket access.
Answer B - correct because bucket policy must allow cross-bucket requests.
Answer C - wrong because open access violates least privilege.
Answer D - wrong because Lambda irrelevant to static hosting.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html

188.Explain
Answer A - wrong because Lambda triggers are configured in CodePipeline, not Lambda console.
Answer B - correct because CodePipeline can directly invoke Lambda actions.
Answer C - wrong because CloudWatch alarm does not monitor pipeline states.
Answer D - wrong because CloudWatch Events uses pipeline state changes, not action-level.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-invoke-lambda-function.html

189.Explain
Answer A - wrong because SAM build not done in EC2.
Answer B - correct because SAM requires local build, package to S3, deploy from S3.
Answer C - wrong because deploy step requires packaging first.
Answer D - wrong because CodeCommit not used for packaging.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html

190.Explain
Answer A - wrong because storing credentials on disk is insecure.
Answer B - wrong because user data not secure for secrets.
Answer C - correct because EC2 role provides temporary credentials securely.
Answer D - wrong because S3 service roles cannot attach to EC2.
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

191.Explain
Answer A - correct because S3 change event can trigger CodePipeline.
Answer B - wrong because EBS volume cannot trigger pipelines.
Answer C - correct because CodeCommit can trigger pipelines on commit.
Answer D - wrong because 15-minute interval not real-time trigger.
Answer E - wrong because ephemeral storage not persistent.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-trigger-source-revisions.html

192.Explain
Answer A - wrong because single EC2 instance not scalable.
Answer B - correct because Auto Scaling EC2 workers scale message processing.
Answer C - wrong because Lambda timeout cannot exceed 15 minutes.
Answer D - wrong because direct RDS insert risks failure under load.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-consumer-application.html

193.Explain
Answer A - wrong because language change not main factor.
Answer B - wrong because Lambda layer does not reduce cold start.
Answer C - wrong because CPU allocation not direct setting.
Answer D - correct because more memory increases CPU power and reduces duration.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html

194.Explain
Answer A - wrong because EC2 not needed to resolve dependencies.
Answer B - wrong because RDS migration irrelevant to failure.
Answer C - correct because rollback restores last working Lambda version.
Answer D - wrong because redeploying in new region unnecessary.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html

195.Explain
Answer A - correct because DynamoDB can persist sessions across instances.
Answer B - wrong because Cognito not for internal session state.
Answer C - correct because ElastiCache provides fast in-memory session storage.
Answer D - wrong because EBS not shared storage.
Answer E - wrong because SQS not used for state persistence.
link ref: https://docs.aws.amazon.com/elasticache/latest/mem-ug/session-storage.html

196.Explain
Answer A - wrong because SDK alone does not push logs to CloudWatch.
Answer B - correct because CloudWatch agent can be installed on-premises.
Answer C - wrong because S3 upload does not integrate real-time.
Answer D - wrong because EC2 relay not efficient for logs.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/install-CloudWatch-Agent-on-premise.html

197.Explain
Answer A - wrong because identity pool tokens do not auto-expire like user pool tokens.
Answer B - wrong because manual database tracking not scalable.
Answer C - correct because user pool with Cognito Authorizer issues expiring JWT tokens.
Answer D - wrong because IAM users not suitable for app users.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html

198.Explain
Answer A - wrong because adding frameworks increases package size.
Answer B - correct because smaller package reduces cold start.
Answer C - correct because more memory allocates more CPU.
Answer D - wrong because timeout does not reduce cold start.
Answer E - wrong because async invocation mode not related.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

199.Explain
Answer A - wrong because VPN logs show tunnel, not subnet flow.
Answer B - wrong because BGP logs not capture EC2 traffic.
Answer C - correct because VPC Flow Logs show accepted/rejected traffic.
Answer D - wrong because CloudTrail records API calls, not traffic.
link ref: https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html

200.Explain
Answer A - wrong because EncryptionConfiguration not related to SSE-KMS.
Answer B - wrong because bucket policy controls access, not KMS usage.
Answer C - correct because PutObject with SSE-KMS requires kms:GenerateDataKey permission.
Answer D - wrong because ACL not control encryption permissions.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

201.Explain
Answer A - correct because Cognito hosted UI supports branding and custom logo.
Answer B - wrong because you cannot upload a custom page directly into Cognito.
Answer C - wrong because API Gateway cannot serve as a login UI.
Answer D - wrong because logo upload alone does not create a login page.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-app-ui-customization.html

202.Explain
Answer A - wrong because DeleteItem not needed.
Answer B - wrong because DescribeTable not needed for item update.
Answer C - wrong because GetRecords and UpdateTable irrelevant.
Answer D - correct because UpdateItem, GetItem, and PutItem support both update and create if not exist.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html

203.Explain
Answer A - wrong because SSE-S3 does not provide key usage audit trail.
Answer B - correct because SSE-KMS logs all key use in CloudTrail.
Answer C - wrong because SSE-C managed outside AWS KMS.
Answer D - wrong because self-managed keys add unnecessary overhead.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

204.Explain
Answer A - wrong because scaling instances does not reduce latency for static files.
Answer B - wrong because Lambda not needed for static content.
Answer C - wrong because vertical scaling increases cost without solving latency.
Answer D - correct because CloudFront caches static content globally.
Answer E - correct because S3 offloads static content delivery.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html

205.Explain
Answer A - wrong because presigned URL expires and not long-term.
Answer B - correct because S3 key storage with VPC endpoint provides private persistent access.
Answer C - wrong because base64 encoding inefficient for large images.
Answer D - wrong because generating presigned URL on every login adds unnecessary overhead.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/privatelink-interface-endpoints.html

206.Explain
Answer A - wrong because multiple Regions does not reduce runtime.
Answer B - wrong because Availability Zones do not affect Lambda performance.
Answer C - wrong because layers only provide shared code.
Answer D - correct because increasing memory increases CPU proportionally.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html

207.Explain
Answer A - correct because application must update DB connection endpoint.
Answer B - wrong because SDK not required for static credentials.
Answer C - wrong because new EC2 instance unnecessary.
Answer D - wrong because Lambda not used for routing DB traffic.
link ref: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html

208.Explain
Answer A - correct because target tracking automatically scales ECS tasks based on SQS metrics.
Answer B - wrong because Docker Swarm not used in ECS.
Answer C - wrong because service scheduler not auto-scales.
Answer D - wrong because step scaling less efficient for variable demand.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-autoscaling-targettracking.html

209.Explain
Answer A - wrong because IAM not for end-user auth.
Answer B - wrong because identity pools only federate identities.
Answer C - correct because user pools handle sign-up and social login.
Answer D - wrong because Directory Service is for enterprise AD integration.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html

210.Explain
Answer A - correct because Lambda authorizer can validate credentials against DynamoDB.
Answer B - wrong because model cannot perform authentication.
Answer C - wrong because integration request cannot query DynamoDB directly.
Answer D - wrong because Cognito authorizer uses user pools, not DynamoDB.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html

211.Explain
Answer A - wrong because GetFederationToken used for temporary federated users.
Answer B - wrong because GetCallerIdentity only returns identity info.
Answer C - correct because GetSessionToken retrieves MFA-protected temporary credentials.
Answer D - wrong because DecodeAuthorizationMessage used for decoded errors only.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html

212.Explain
Answer A - correct because AWS Support can increase KMS request quota.
Answer B - correct because exponential backoff handles throttling.
Answer C - wrong because S3 limit unrelated.
Answer D - wrong because CMK key size not affect throttling.
Answer E - wrong because multiple keys do not increase rate limit.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/limits.html

213.Explain
Answer A - wrong because handler separation is design practice only.
Answer B - wrong because CloudWatch Events not send data notifications.
Answer C - correct because SNS can fan-out processed data to admins.
Answer D - wrong because SQS queues not used for notification delivery.
link ref: https://docs.aws.amazon.com/sns/latest/dg/sns-publish-lambda.html

214.Explain
Answer A - wrong because client-side encryption not automate rotation.
Answer B - wrong because imported key rotation must be manual.
Answer C - correct because KMS can rotate keys annually automatically.
Answer D - wrong because exported keys insecure.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html

215.Explain
Answer A - wrong because header alone cannot separate versions in API Gateway.
Answer B - wrong because authorizer not used for routing.
Answer C - wrong because resource policy not for version control.
Answer D - correct because separate stages with variables isolate versions effectively.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html

216.Explain
Answer A - wrong because Encrypt API cannot handle large data directly.
Answer B - wrong because key size irrelevant for large data.
Answer C - correct because GenerateDataKey returns data key for local encryption.
Answer D - wrong because GenerateDataKeyWithoutPlaintext cannot encrypt directly.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#data-keys

217.Explain
Answer A - wrong because GitHub token not used with CodeCommit.
Answer B - wrong because SSH keys used for SSH connections not HTTPS.
Answer C - correct because HTTPS access to CodeCommit requires IAM Git credentials.
Answer D - wrong because EC2 role irrelevant for repository access.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-gc.html

218.Explain
Answer A - wrong because GetItem retrieves only one item.
Answer B - correct because BatchGetItem retrieves multiple items per request.
Answer C - wrong because GetMultipleItems not valid API call.
Answer D - wrong because GetItemRange not exist in DynamoDB API.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchGetItem.html

219.Explain
Answer A - wrong because private subnet ENI not used for NAT.
Answer B - wrong because private instance should not be public.
Answer C - correct because disabling Source/Destination Check enables NAT traffic forwarding.
Answer D - wrong because private subnet instance not require Elastic IP.
link ref: https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html

220.Explain
Answer A - correct because S3 in US-STANDARD uses eventual consistency for new PUTs.
Answer B - wrong because replication not required for visibility.
Answer C - wrong because no fixed delay in S3.
Answer D - wrong because bucket limit not related to consistency.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/Introduction.html#ConsistencyModel

221.Explain  
Answer A - wrong because S3 limits are not per region.  
Answer B - wrong because S3 bucket count is limited.  
Answer C - correct because AWS allows up to 1,000,000 buckets per account (as per 2023 update).  
Answer D - wrong because 500 per account is outdated.  
Answer E - wrong because bucket limits apply per account, not IAM user.  
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/BucketRestrictions.html  

222.Explain  
Answer A - wrong because IAM users require key storage, which is disallowed.  
Answer B - wrong because roles must be attached at launch time.  
Answer C - wrong because IAM users cannot be added to EC2 directly.  
Answer D - correct because the IAM role must be attached during EC2 launch.  
Answer E - correct because the IAM role defines write access to DynamoDB.  
Answer F - wrong because IAM users cannot be assigned via launch configuration.  
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html  

223.Explain  
Answer A - correct because the default evaluation starts with an implicit deny.  
Answer B - wrong because explicit deny always overrides any allow.  
Answer C - correct because an explicit allow overrides the default deny.  
Answer D - wrong because explicit deny takes precedence.  
Answer E - wrong because requests are denied by default.  
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html  

224.Explain  
Answer A - wrong because NAT instance is used for private subnets.  
Answer B - wrong because the routing table is already correct for other instances.  
Answer C - wrong because host-level IP changes do not allocate a public address.  
Answer D - correct because assigning an Elastic IP gives the instance internet access.  
link ref: https://docs.aws.amazon.com/vpc/latest/userguide/vpc-ip-addressing.html#vpc-public-ip  

225.Explain  
Answer A - wrong because 0 seconds means no invisibility.  
Answer B - wrong because 1 hour exceeds default timeout.  
Answer C - wrong because 1 day is too long.  
Answer D - wrong because messages are not permanently hidden.  
Answer E - correct because SQS default visibility timeout is 30 seconds.  
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html  

226.Explain  
Answer A - wrong because SNS uses JSON, not XML.  
Answer B - wrong because DuplicateFlag is not part of SNS message format.  
Answer C - wrong because SNS messages are JSON, not XML.  
Answer D - correct because SNS sends JSON objects containing MessageId, unsubscribeURL, Subject, and Message.  
link ref: https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html  

227.Explain  
Answer A - wrong because storage class defines redundancy, not encryption.  
Answer B - wrong because Content-MD5 validates integrity, not encryption.  
Answer C - wrong because security tokens relate to session authentication.  
Answer D - correct because `x-amz-server-side-encryption` specifies SSE mode.  
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingServerSideEncryption.html  

228.Explain  
Answer A - correct because Elastic Beanstalk supports Apache Tomcat.  
Answer B - correct because .NET on Windows Server is supported.  
Answer C - wrong because IBM WebSphere is not supported.  
Answer D - wrong because Oracle JBoss is unsupported.  
Answer E - wrong because Jetty is not supported directly.  
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts-platforms.html  

229.Explain  
Answer A - correct because Fn::GetAtt retrieves DNSName and Fn::Join forms the URL string.  
Answer B - wrong because “Url” is not a valid attribute.  
Answer C - wrong because Ref cannot reference a URL.  
Answer D - wrong because Ref + DNSName is invalid syntax.  
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getatt.html  

230.Explain  
Answer A - wrong because virtual hosting affects addressing, not access control.  
Answer B - correct because bucket policy allows granular access restrictions.  
Answer C - wrong because IAM federation handles identity, not bucket access directly.  
Answer D - correct because ACLs provide object-level access control.  
Answer E - wrong because CloudFront does not restrict access by itself.  
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-overview.html  

231.Explain  
Answer A - wrong because rollback deletes all created resources.  
Answer B - correct because CloudFormation rolls back when creation fails.  
Answer C - wrong because stack creation stops after rollback.  
Answer D - wrong because templates are validated but not guaranteed.  
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-rollback.html  

232.Explain  
Answer A - correct because TopicArn identifies SNS topic.  
Answer B - correct because Subject is an optional field.  
Answer C - wrong because Destination is used in SES, not SNS.  
Answer D - wrong because Format not used in Publish API.  
Answer E - correct because Message is required.  
Answer F - wrong because Language is not a valid parameter.  
link ref: https://docs.aws.amazon.com/sns/latest/api/API_Publish.html  

233.Explain  
Answer A - wrong because CloudWatch tracks metrics, not instance details.  
Answer B - wrong because CLI commands only show IPs from OS.  
Answer C - wrong because user data is user-defined, not instance metadata.  
Answer D - correct because instance metadata provides public and private IPs.  
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html  

234.Explain  
Answer A - wrong because AMIs are region-specific.  
Answer B - wrong because AWS regions are not grouped by country.  
Answer C - correct because AMIs must be copied across regions to reuse.  
Answer D - wrong because AMIs are regional, not AZ-specific.  
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html  

235.Explain  
Answer A - wrong because DescribeInstances lists EC2 instances.  
Answer B - wrong because DescribeAMIs is not a valid API call.  
Answer C - correct because DescribeImages returns AMI information.  
Answer D - wrong because GetAMIs does not exist.  
Answer E - wrong because AMIs are retrievable through API or console.  
link ref: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html  

236.Explain  
Answer A - correct because IAM credentials management is user responsibility.  
Answer B - wrong because AWS handles hardware decommissioning.  
Answer C - correct because network-level settings are managed by customers.  
Answer D - correct because EBS encryption choice is customer-managed.  
Answer E - wrong because AWS controls data center access.  
Answer F - correct because OS-level patching is the customer’s duty.  
link ref: https://docs.aws.amazon.com/whitepapers/latest/aws-shared-responsibility-model/aws-shared-responsibility-model.html  

237.Explain  
Answer A - correct because smaller page size reduces read capacity impact.  
Answer B - wrong because parallel scans increase throughput usage.  
Answer C - wrong because indexes don’t affect scan limits.  
Answer D - wrong because “prewarming” is irrelevant in DynamoDB.  
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html  

238.Explain  
Answer A - wrong because SSL applies to data in transit, not at rest.  
Answer B - wrong because data sequence doesn’t affect security.  
Answer C - correct because encrypted file systems like LUKS or BitLocker protect EBS data.  
Answer D - wrong because S3 encryption is unrelated to EBS.  
Answer E - wrong because IAM controls access, not encryption.  
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html  

239.Explain  
Answer A - wrong because ap-northeast-1 is Tokyo region.  
Answer B - wrong because us-west-2 is Oregon.  
Answer C - correct because us-east-1 (N. Virginia) is the default region.  
Answer D - wrong because eu-west-1 (Ireland) is not default.  
Answer E - wrong because us-central-1 does not exist.  
link ref: https://docs.aws.amazon.com/general/latest/gr/rande.html  

240.Explain  
Answer A - correct because SWF ensures single task assignment.  
Answer B - wrong because SWF does not require S3.  
Answer C - correct because workflows can run for up to one year.  
Answer D - wrong because SWF does not auto-integrate with SNS.  
Answer E - correct because SWF uses deciders and workers model.  
Answer F - wrong because SWF domains do not require EC2.  
link ref: https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html  

241.Explain
The issue is that the **single load-testing EC2 instance** resolved the ELB's DNS name only once at the beginning of the test. Due to the way ELB returns multiple IP addresses and how clients/DNS resolvers typically cache these responses (Time-to-Live, or TTL), the single client only used the IPs corresponding to the ELB nodes running in the same Availability Zone as the client (or the first two AZs returned). The ELB nodes receiving traffic only forwarded it to webservers in their AZ (`us-west-2a`), leaving webservers in the other AZ (`us-west-2b`) idle.

A. Wrong - Launching from `us-east-1` would not guarantee better distribution; the DNS caching problem would persist, potentially favoring a different subset of ELB nodes/AZs.
B. Correct - **Re-configure the load-testing software to re-resolve DNS for each web request.** This forces the client to query DNS repeatedly. Since the ELB DNS entry rotates the IPs of the available load balancer nodes (Round-Robin DNS), constantly re-resolving the name will ensure the client is directed to all available ELB nodes and, consequently, all back-end web servers.
C. Correct - **Use a 3rd-party load-testing service which offers globally-distributed test clients.** The problem is confined to a single client (IP/EC2 instance). Using multiple, geographically distributed clients inherently ensures better distribution across all ELB nodes and AZs, naturally solving the DNS caching/single client issue.
D. Wrong - The current configuration is already distributing across two subnets (`us-west-2a` and `us-west-2b`), which is the correct setup. Changing the AZs doesn't fix the client's DNS caching behavior.
E. Wrong - Session stickiness (TTL of 5 minutes) is likely what's keeping individual requests from the beta users consistent, but the load-tester's issue is **reaching the load balancer nodes themselves**, not the stickiness to a specific web server. Stickiness is irrelevant if the traffic never reaches the full set of load balancer nodes.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html

242.Explain
Answer A correct because HTTP.
Answer B wrong because UDP no.
Answer C correct because SMS.
Answer D wrong because DynamoDB no.
Answer E wrong because pipes no.
link ref: https://aws.amazon.com/sns/features/

243.Explain
Answer A wrong because serialize multiple no.
Answer B wrong because Images table foreign complex.
Answer C wrong because binary size.
Answer D correct because S3 URL pointer low.
link ref: https://aws.amazon.com/dynamodb/

244.Explain
Answer A wrong because hash no.
Answer B wrong because storage no.
Answer C correct because tables.
Answer D wrong because LSI no.
Answer E correct because throughput.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html

245.Explain
Answer A correct because timeout process delete.
Answer B wrong because delete before loss.
Answer C wrong because DelaySeconds delay.
Answer D wrong because delete before.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html

246.Explain
Answer A wrong because anonymous no.
Answer B correct because pre-signed download.
Answer C wrong because MFA no.
Answer D wrong because encryption no access.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html

247.Explain
Answer A correct because User ID even.
Answer B wrong because Status same.
Answer C wrong because Device hot.
Answer D wrong because Game few.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html

248.Explain
Answer A wrong because hash name range office sort.
Answer B correct because range name hash office query.
Answer C wrong because hash name no range.
Answer D wrong because hash office no range.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html

249.Explain
Answer A wrong because VPC for both.
Answer B correct because EBS persists on stop/start.
Answer C wrong because ASG for both.
Answer D wrong because instance-store no stop/start.
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/RootDeviceStorage.html

250.Explain
Answer A wrong because S3 costs.
Answer B wrong because EC2 costs.
Answer C correct because Auto Scaling free.
Answer D wrong because ELB costs.
Answer E correct because CloudFormation free.
Answer F wrong because SWF costs.
link ref: https://aws.amazon.com/pricing/

251.Explain
Answer A wrong because limit 5TB now, but was 5GB.
Answer B correct because multi-part for >5GB.
Answer C wrong because no large API.
Answer D wrong because no support increase.
Answer E wrong because region not limit.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html

252.Explain
Answer A correct because ASG deployed.
Answer B wrong because Route 53 separate.
Answer C correct because ELB deployed.
Answer D correct because RDS optional.
Answer E wrong because EIP manual.
Answer F wrong because SQS separate.
link ref: https://aws.amazon.com/elasticbeanstalk/

253.Explain
Answer A wrong because IAM user creds insecure.
Answer B wrong because root creds bad.
Answer C correct because web federation temp creds.
Answer D wrong because cross-account for accounts.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html

254.Explain
Answer A wrong because Perl supported.
Answer B correct because PHP supported.
Answer C wrong because Pascal not.
Answer D correct because Java supported.
Answer E wrong because SQL not SDK.
link ref: https://aws.amazon.com/tools/

255.Explain
Answer A wrong because 1 too low.
Answer B correct because 600/60=10 WCU for 1KB writes.
Answer C wrong because 60 over.
Answer D wrong because 600 over.
Answer E wrong because 3600 way over.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

256.Explain
Answer A wrong because 5xx server errors.
Answer B wrong because 200 success.
Answer C wrong because 306 unused.
Answer D correct because 4xx client errors.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/CommonErrors.html

257.Explain
Answer A wrong because visibility after receive.
Answer B correct because long polling waits 20s reduces empty.
Answer C wrong because retention for delete.
Answer D wrong because delay for new messages.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html

258.Explain
Answer A wrong because no www.
Answer B correct because s3-website-region format.
Answer C wrong because no endpoint.
Answer D wrong because no tokyo.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteEndpoints.html

259.Explain
Answer A wrong because single table accumulates.
Answer B wrong because individual delete costly.
Answer C correct because delete/create per hour minimal provision.
Answer D wrong because create without delete accumulates.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.DeleteTable.html

260.Explain
Answer A wrong because memory not shared.
Answer B wrong because storage not shared.
Answer C wrong because EBS not easily shared.
Answer D correct because ElastiCache shared sessions.
Answer E wrong because Glacier archival.
link ref: https://aws.amazon.com/elasticache/

261.Explain
Answer A wrong because EBS not for serving.
Answer B correct because signed URLs control access.
Answer C wrong because CloudFront can use signed too.
Answer D wrong because SG for EC2, not S3.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html

262.Explain
Answer A wrong because pessimistic not used.
Answer B correct because optimistic control.
Answer C correct because conditional writes.
Answer D wrong because no restrict reads.
Answer E wrong because no restrict writes.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate

263.Explain
Answer A wrong because bulk not for devices.
Answer B wrong because push service handles, but SNS needs register.
Answer C wrong because vending for custom.
Answer D correct because CreatePlatformEndpoint registers tokens.
link ref: https://docs.aws.amazon.com/sns/latest/dg/sns-mobile-application-as-subscriber.html

264.Explain
Answer A wrong because no storage instances.
Answer B wrong because range secondary.
Answer C correct because hot hash key throttling.
Answer D wrong because sort not capacity.
Answer E wrong because no auto scaling then.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html

265.Explain
Answer A wrong because sequential hotspots.
Answer B correct because instanceID first distributes.
Answer C wrong because year first less distribution.
Answer D wrong because hour first hotspots.
Answer E wrong because year hotspots.
link ref: https://aws.amazon.com/premiumsupport/knowledge-center/s3-request-limit-avoid/

266.Explain
Answer A wrong because not exactly once/FIFO.
Answer B wrong because not exactly once.
Answer C wrong because FIFO order.
Answer D correct because at-least-once, no order.
link ref: https://aws.amazon.com/sqs/features/

267.Explain
Answer A wrong because IAM no LDAP login.
Answer B correct because LDAP to STS assume role.
Answer C wrong because STS no LDAP.
Answer D correct because broker LDAP to STS federated.
Answer E wrong because broker to STS assume.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html

268.Explain
Answer A correct because upload welcome.html.
Answer B wrong because no subfolder needed.
Answer C correct because set index to welcome.html.
Answer D wrong because move index unnecessary.
Answer E wrong because error for errors.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/IndexDocumentSupport.html

269.Explain
Answer A wrong because Triple DES not S3.
Answer B correct because AES-256 SSE.
Answer C wrong because Blowfish not.
Answer D wrong because RC5 not.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html

270.Explain
Answer A correct because annotations for custom data indexed.
Answer B wrong because metadata not indexed.
Answer C wrong because env vars config.
Answer D wrong because plugins SDK.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-annotations

271.Explain
Answer A wrong because no direct select type in deployment.
Answer B correct because new env with ALB, swap CNAME.
Answer C correct because clone change type, swap.
Answer D wrong because edit not change LB type.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.elb.html

272.Explain
Answer A wrong because CodePipeline CI/CD.
Answer B wrong because S3 storage.
Answer C wrong because CodeBuild builds.
Answer D correct because CodeCommit git repo.
link ref: https://aws.amazon.com/codecommit/

273.Explain
Answer A wrong because CodePipeline orchestrates.
Answer B wrong because CodeBuild compiles.
Answer C wrong because Beanstalk PaaS.
Answer D correct because CodeDeploy deploys to EC2/on-prem.
link ref: https://aws.amazon.com/codedeploy/

274.Explain
Answer A wrong because DLQ for async.
Answer B wrong because API Gateway source.
Answer C wrong because error handling not prevent.
Answer D correct because support increase account limit.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-limits.html

275.Explain
Answer A wrong because RDS app level slow.
Answer B wrong because shared file complex.
Answer C correct because Memcached low latency.
Answer D wrong because DynamoDB higher latency.
link ref: https://aws.amazon.com/elasticache/memcached/

276.Explain
Answer A correct because GSI separate provision, underprovisioned.
Answer B wrong because read on primary ok.
Answer C wrong because streams for changes.
Answer D wrong because other table separate.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

277.Explain
Answer A wrong because concurrent no prevent.
Answer B correct because conditional prevent overwrite.
Answer C wrong because atomic per operation.
Answer D wrong because batch no condition across.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate

278.Explain
Answer A wrong because view type for content.
Answer B correct because event source mapping triggers.
Answer C wrong because SNS not needed.
Answer D wrong because timeout not trigger.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html

279.Explain
Answer A wrong because 30s too infrequent.
Answer B correct because high-res every 5s for 15s average.
Answer C wrong because standard 1min.
Answer D wrong because standard infrequent.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

280.Explain
Answer A wrong because SQS/EC2 not real-time.
Answer B wrong because S3/Redshift batch.
Answer C wrong because Data Pipeline scheduled.
Answer D correct because Kinesis Streams real-time ingest.
link ref: https://aws.amazon.com/kinesis/data-streams/

281.Explain
Answer A correct because specific Create/DeleteBranch.
Answer B wrong because Put* too broad.
Answer C wrong because Update* not for branches.
Answer D wrong because * all access.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-permissions-reference.html

282.Explain
Answer A wrong because ACM certs.
Answer B correct because Parameter Store secure storage.
Answer C wrong because Trusted Advisor recommendations.
Answer D correct because KMS encrypts.
Answer E wrong because GuardDuty security.
link ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store.html

283.Explain
Answer A wrong because dockerrun for ECS.
Answer B wrong because buildspec for CodeBuild.
Answer C correct because appspec for deployment hooks.
Answer D wrong because ebextensions config.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file.html

284.Explain
Answer A wrong because Encrypt not for large.
Answer B wrong because GenerateRandom no KMS.
Answer C wrong because encrypted key not decrypt.
Answer D correct because plaintext data key from KMS.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#data-keys

285.Explain
Answer A wrong because CacheHit for caching.
Answer B correct because IntegrationLatency measures backend time.
Answer C wrong because CacheMiss caching.
Answer D correct because Latency total time.
Answer E wrong because Count requests.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-metrics-and-dimensions.html

286.Explain
Answer A correct because CloudFront signed URLs secure cheap.
Answer B wrong because per customer costly.
Answer C wrong because Lambda@Edge custom.
Answer D wrong because API/Lambda overhead.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-signed-urls.html

287.Explain
Answer A correct because backoff handles throttling.
Answer B wrong because SQS bus adds layer.
Answer C wrong because API Gateway throttles more.
Answer D wrong because Firehose for streams.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html

288.Explain
Answer A correct because ElastiCache shared sessions fault-tolerant.
Answer B wrong because CloudFront CDN.
Answer C wrong because S3 not low latency.
Answer D wrong because sticky not fault-tolerant.
link ref: https://aws.amazon.com/elasticache/

289.Explain
Answer A wrong because intrinsic for functions.
Answer B wrong because express framework.
Answer C correct because SAM model for serverless.
Answer D wrong because plugin not.
link ref: https://aws.amazon.com/serverless/sam/

290.Explain
Answer A wrong because pessimistic DynamoDB no.
Answer B wrong because CloudFront/ASG not session.
Answer C wrong because WAF security.
Answer D correct because DynamoDB external sessions.
Answer E correct because ELB/ASG for elasticity.
link ref: https://aws.amazon.com/elasticloadbalancing/

291.Explain
Answer A wrong because logging basic.
Answer B wrong because CloudTrail API.
Answer C correct because X-Ray traces distributed.
Answer D wrong because Inspector security.
link ref: https://aws.amazon.com/xray/

292.Explain
Answer A wrong because no VPC endpoint for logs.
Answer B correct because filters apply forward.
Answer C wrong because no ES needed.
Answer D wrong because no export needed.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/MonitoringLogData.html

293.Explain
Answer A wrong because Conditions optional.
Answer B wrong because Globals optional.
Answer C correct because Transform for SAM.
Answer D wrong because Properties per resource.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification.html

294.Explain
Answer A wrong because Multi-AZ HA.
Answer B wrong because SQS messaging.
Answer C correct because ElastiCache caches queries.
Answer D wrong because replica scales reads.
link ref: https://aws.amazon.com/elasticache/

295.Explain
Answer A wrong because concurrent account limit.
Answer B wrong because stage for API.
Answer C correct because function reserved concurrency limits.
Answer D wrong because reduce throttling worsens.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html

296.Explain
Answer A correct because Redis cluster shared fault-tolerant.
Answer B wrong because EBS not shared easily.
Answer C wrong because disk local.
Answer D wrong because dedicated instance not shared.
link ref: https://aws.amazon.com/elasticache/redis/

297.Explain
Answer A wrong because YAML ok.
Answer B correct because .config extension for ebextensions.
Answer C wrong because resources for declare.
Answer D wrong because namespace custom unnecessary.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html

298.Explain
Answer A wrong because instance size not for Lambda.
Answer B wrong because time increase not compute.
Answer C wrong because call-time specify not possible.
Answer D correct because more memory increases CPU proportionally.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/resource-model.html

299.Explain
Answer A wrong because async Lambda still waits for login.
Answer B correct because Memcached caches user data, speeding login.
Answer C wrong because ALB balances, but bottleneck is DB.
Answer D correct because async DB call doesn't block.
Answer E wrong because batch increases latency.
link ref: https://aws.amazon.com/elasticache/memcached/

300.Explain
Answer A wrong because identity pools for auth.
Answer B wrong because user pool for auth.
Answer C correct because Cognito Sync for cross-device data.
Answer D wrong because events for triggers.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-sync.html

301.Explain
Answer A wrong because deployment for stages.
Answer B wrong because authorizer for auth.
Answer C wrong because import for keys, but need plan association.
Answer D correct because usage plan key associates key to plan.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html

302.Explain
Answer A correct because Cognito web federation for social logins.
Answer B wrong because SAML for enterprise.
Answer C wrong because keys in code insecure.
Answer D wrong because STS assume for roles.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-integrating-amazon-cognito-with-web-and-mobile-apps.html

303.Explain
Answer A wrong because GetMetricData for metrics, not logs.
Answer B wrong because CloudTrail for API calls.
Answer C wrong because CloudWatch Events for triggers.
Answer D correct because CloudWatch Logs agent collects EC2 logs.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/QuickStartEC2Instance.html

304.Explain
Answer A wrong because DeleteItem conditional slow for millions.
Answer B wrong because BatchWriteItem limited.
Answer C wrong because recursive slow.
Answer D correct because recreate table daily efficient for temp data.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.CreateTable.html

305.Explain
Answer A wrong because bucket name not cause duplicates.
Answer B correct because Lambda retries on failure, causing duplicates.
Answer C wrong because no S3 outage mentioned.
Answer D wrong because intermittent stop not cause log duplicates.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-retries.html

306.Explain
Answer A wrong because Lambda is compute.
Answer B wrong because X-Ray tracing.
Answer C wrong because SQS messaging.
Answer D correct because API Gateway centralizes microservices.
link ref: https://aws.amazon.com/api-gateway/

307.Explain
Answer A correct because S3 with CloudFront for static content.
Answer B wrong because EC2 self-managed.
Answer C wrong because ECS/Redis container/dynamic.
Answer D wrong because Lambda/API for dynamic.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html

308.Explain
Answer A wrong because namespace for grouping.
Answer B correct because dimension for filtering metrics per app.
Answer C wrong because event for triggers.
Answer D wrong because alarm on metrics.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html

309.Explain
Answer A wrong because STS temp, but user pools for passwords.
Answer B wrong because IAM not for password reset.
Answer C wrong because KMS encryption.
Answer D correct because user pools handle sign-up and reset.
link ref: https://aws.amazon.com/cognito/

310.Explain
Answer A wrong because CodeCommit multiple repos not for envs.
Answer B wrong because CodeBuild for builds.
Answer C wrong because Data Pipeline for data.
Answer D correct because CodeDeploy groups for envs.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-groups.html

311.Explain
Answer A wrong because new table per date not minimal cost.
Answer B wrong because increasing units costly during spikes.
Answer C correct because random suffix even distribution.
Answer D wrong because GSI for queries, not writes.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html

312.Explain
Answer A wrong because S3 not in-memory.
Answer B wrong because RDS relational.
Answer C correct because ElastiCache in-memory for consistent results.
Answer D wrong because Kinesis streaming.
link ref: https://aws.amazon.com/elasticache/

313.Explain
Answer A correct because task definition defines port mappings.
Answer B wrong because cluster is group.
Answer C wrong because Dockerfile for image.
Answer D wrong because CLI for management.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

314.Explain
Answer A wrong because KMS for keys.
Answer B correct because instance profiles provide creds securely.
Answer C wrong because root insecure.
Answer D wrong because CodeCommit for code.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

315.Explain
Answer A wrong because RDS queryable but not for metrics.
Answer B wrong because X-Ray with Lambda for tracing.
Answer C wrong because Kinesis/DynamoDB complex.
Answer D correct because CloudWatch custom metrics with alarms cost-effective.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

316.Explain
Answer A wrong because all at once outage.
Answer B wrong because rolling outage.
Answer C wrong because snapshots backup.
Answer D correct because immutable no outage, quick rollback.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

317.Explain
Answer A wrong because S3 cache manual.
Answer B wrong because RDS not origin for CloudFront.
Answer C wrong because EC2 local not scalable.
Answer D correct because ElastiCache fronts RDS for reads.
link ref: https://aws.amazon.com/elasticache/

318.Explain
Answer A wrong because 3 RCU for 3 items, but strong consistent 2x.
Answer B correct because 3 items * 5KB = 15KB, strong read 2 RCU per 4KB, so 6 RCU.
Answer C wrong because write 70 for 10 items * 7KB.
Answer D wrong because read 3, write 10 incorrect.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

319.Explain
Answer A wrong because pointer advance needed.
Answer B wrong because event source sync.
Answer C correct because unhandled error causes retry.
Answer D wrong because keeping up not issue.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html

320.Explain
Answer A wrong because role for DB access direct insecure.
Answer B correct because Parameter Store SecureString with rotation.
Answer C wrong because S3 metadata not secure.
Answer D wrong because hardcode no rotation.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

321.Explain
Answer A wrong because another function duplicate.
Answer B correct because update-function-code updates code.
Answer C wrong because remove not needed.
Answer D wrong because alias for versions.
link ref: https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-code.html

322.Explain
Answer A correct because private subnet for VPC access.
Answer B wrong because NACL outbound default.
Answer C correct because NAT for internet from private.
Answer D wrong because public subnet no DB access.
Answer E wrong because env var not for access.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html

323.Explain
Answer A wrong because same key no update detection.
Answer B correct because update stack properties to new S3 version.
Answer C wrong because base64 not for code.
Answer D wrong because role for access, but update needed.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html

324.Explain
Answer A correct because Docker image with daemon.
Answer B correct because instrument code.
Answer C wrong because daemon not on EC2 for ECS.
Answer D wrong because instance role for EC2, not tasks.
Answer E wrong because register app not needed.
Answer F correct because task role for permissions.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-docker.html

325.Explain
Answer A wrong because acl condition not for encryption.
Answer B wrong because RDS not for S3.
Answer C wrong because SecureTransport for transit.
Answer D correct because default SSE-S3 encrypts at rest.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/default-bucket-encryption.html

326.Explain
Answer A wrong because Parameters inputs.
Answer B wrong because Outputs results.
Answer C correct because Mappings for region-specific AMIs.
Answer D wrong because Resources define.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/mappings-section-structure.html

327.Explain
Answer A wrong because scan consumes more.
Answer B wrong because strong consistent more RCU.
Answer C correct because query eventual minimal RCU.
Answer D wrong because scan strong more.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html

328.Explain
Answer A wrong because remove origin resets.
Answer B wrong because forwarding not for cache.
Answer C correct because invalidate forces refresh.
Answer D wrong because disable propagates old.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html

329.Explain
Answer A wrong because CodeCommit for code, but reference in template.
Answer B correct because inline code in template.
Answer C correct because S3 zip reference in template.
Answer D wrong because zip to CloudFormation not standard.
Answer E wrong because Git private not direct.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html

330.Explain
Answer A wrong because S3 for storage.
Answer B wrong because zip local not for libs.
Answer C wrong because blueprint templates.
Answer D wrong because runtime fixed.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

331.Explain
Answer A wrong because pass-through no encryption.
Answer B correct because certificates on ELB offload CPU.
Answer C wrong because LSS not exist.
Answer D wrong because install on EC2 increases CPU.
Answer E correct because termination on ELB offloads.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-create-https-ssl-load-balancer.html

332.Explain
Answer A correct because zip with all libs.
Answer B wrong because runtime script increases time.
Answer C wrong because S3 env var for path, but not standard.
Answer D wrong because buildspec for CodeBuild.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

333.Explain
Answer A wrong because sticky for same instance.
Answer B wrong because SQS not for sessions.
Answer C correct because DynamoDB scalable for sessions.
Answer D wrong because draining for termination.
link ref: https://aws.amazon.com/blogs/aws/elastic-load-balancer-support-for-amazon-dynamodb/

334.Explain
Answer A wrong because Glue ETL not real-time.
Answer B wrong because ElastiCache not for updates.
Answer C wrong because Firehose delivery, not updates.
Answer D correct because Streams capture changes near-real time.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html

335.Explain
Answer A wrong because Subversion centralized.
Answer B wrong because CodeBuild builds.
Answer C correct because CodeCommit distributed git.
Answer D wrong because CodeStar projects.
link ref: https://aws.amazon.com/codecommit/

336.Explain
Answer A wrong because EC2 cron managed.
Answer B wrong because env var not for scheduling.
Answer C correct because CloudWatch Events schedule Lambda.
Answer D wrong because SNS timer not standard.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents.html

337.Explain
Answer A wrong because query not sort by score.
Answer B correct because GSI with sport_name partition, score sort for top.
Answer C wrong because scan inefficient.
Answer D wrong because LSI per partition.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

338.Explain
Answer A wrong because provider for auth.
Answer B wrong because Lambda user creation complex.
Answer C wrong because KMS for encryption.
Answer D correct because Cognito unauth roles for limited access.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html

339.Explain
Answer A correct because bucket policy grants key access? Wait, no - for SSE-KMS, role needs KMS access.
Wait, correction based on standard: 
Answer A wrong because bucket policy for S3, but KMS for decrypt.
Answer B correct because IAM role on EC2 needs KMS decrypt permission.
Answer C wrong because key policy enables, but instance needs access.
Answer D wrong because ACL for objects.
Answer E wrong because Parameter for storage.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/iam-policies.html

340.Explain
Answer A correct because delay hides on add.
Answer B wrong because after consume not delay.
Answer C wrong because poll time consumer side.
Answer D wrong because delete delay not exist.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-delay-queues.html

341.Explain
Answer A wrong because S3 direct not for concurrent.
Answer B wrong because FTP central, not AWS.
Answer C correct because CodeCommit with direct deploy minimizes time.
Answer D wrong because EC2 repo central bottleneck.
link ref: https://aws.amazon.com/codecommit/

342.Explain
Answer A wrong because EMR big data.
Answer B correct because DAX caches DynamoDB reads.
Answer C wrong because SQS messaging.
Answer D wrong because CloudFront CDN.
link ref: https://aws.amazon.com/dynamodb/dax/

343.Explain
Answer A wrong because default SSE-S3 not client-side.
Answer B wrong because Cognito auth, not encryption.
Answer C wrong because Lambda for processing.
Answer D correct because client-side with KMS secure transmission/storage.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingClientSideEncryption.html

344.Explain
Answer A wrong because role AROA... is assumed role.
Answer B wrong because default role not used.
Answer C correct because ASge... is access key of principal.
Answer D wrong because account owns service.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html

345.Explain
Answer A correct because pagination handles large lists.
Answer B wrong because shorthand syntax for input.
Answer C wrong because parameters for commands.
Answer D wrong because quoting for args.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-pagination.html

346.Explain
Answer A wrong because security groups for network.
Answer B wrong because ECR for images.
Answer C wrong because agent runs containers.
Answer D correct because task definition defines ports.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

347.Explain
Answer A correct because DynamoDB NoSQL for metadata indexing.
Answer B wrong because EC2 not storage.
Answer C wrong because Lambda compute.
Answer D wrong because RDS relational slower for indexing.
link ref: https://aws.amazon.com/dynamodb/

348.Explain
Answer A wrong because VPC Flow for network.
Answer B correct because CloudWatch Logs for app logs.
Answer C wrong because CloudSearch for search.
Answer D wrong because CloudTrail for API.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html

349.Explain
Answer A wrong because KPL for producers.
Answer B wrong because reduce retention less data.
Answer C correct because UpdateShardCount increases capacity.
Answer D wrong because PutRecords batches puts, but for high throughput shards needed.
link ref: https://docs.aws.amazon.com/streams/latest/dev/developing-producers-with-kpl.html

350.Explain
Answer A correct because nested for reusable patterns.
Answer B wrong because credentials insecure.
Answer C wrong because remove mappings reduces flexibility.
Answer D wrong because Include for snippets, but public risky.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/best-practices.html

351.Explain
Answer A correct because backoffs for rate limits.
Answer B wrong because load balance not for API.
Answer C wrong because EC2 not help.
Answer D wrong because delay worsens.
link ref: https://docs.aws.amazon.com/general/latest/gr/api-retries.html

352.Explain
Answer A wrong because script with cron managed.
Answer B correct because TTL auto-deletes old items.
Answer C wrong because new table daily costly.
Answer D wrong because ItemExpiration not standard; use TTL.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-how-to.html

353.Explain
Answer A wrong because split smaller still serial.
Answer B wrong because sync one by one slow.
Answer C correct because async event parallel.
Answer D wrong because join first serial.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html

354.Explain
Answer A correct because multi-part for large objects.
Answer B wrong because Direct Connect network, not size.
Answer C wrong because no support contact for size.
Answer D wrong because region not issue.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html

355.Explain
Answer A wrong because docker pull direct not auth.
Answer B correct because get-login for docker login, then pull.
Answer C wrong because get-login output to run.
Answer D wrong because get-download for layers, not pull.
link ref: https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html

356.Explain
Answer A correct because user pools for email sign-up.
Answer B wrong because Mobile Hub deprecated.
Answer C wrong because Sync for data.
Answer D wrong because cloud logic for backend.
link ref: https://aws.amazon.com/cognito/

357.Explain
Answer A wrong because user creds in code insecure.
Answer B correct because execution role for Lambda secure.
Answer C wrong because bucket policy principal for S3, but Lambda needs role.
Answer D wrong because managed policy too broad.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html

358.Explain
Answer A wrong because KMS not for traffic.
Answer B correct because Origin Protocol HTTPS only.
Answer C wrong because port 443 for origin.
Answer D correct because Viewer Policy HTTPS or redirect.
Answer E wrong because Restrict Viewer for signed URLs.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html

359.Explain
Answer A wrong because 50 for eventual.
Answer B wrong because 100 for eventual 100 items.
Answer C correct because strong consistent 2x RCU, 100 items * 5KB /4KB *2 =200.
Answer D wrong because 500 too much.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

360.Explain
Answer A wrong because S3 logs are access logs.
Answer B wrong because CloudTrail is API calls.
Answer C correct because CloudWatch collects Lambda logs.
Answer D wrong because DynamoDB no logs.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html

361.Explain
Answer A wrong because EBS persistent.
Answer B wrong because EFS shared.
Answer C correct because /tmp for temp, auto-cleaned.
Answer D wrong because S3 persistent.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html

362.Explain
Answer A wrong because CloudFormation templates.
Answer B correct because Beanstalk deploys Tomcat easily.
Answer C wrong because S3 static.
Answer D wrong because CodePipeline CI/CD.
link ref: https://aws.amazon.com/elasticbeanstalk/

363.Explain
Answer A correct because ElastiCache for sessions scalable.
Answer B wrong because EBS not shared.
Answer C wrong because Instance Store not persistent.
Answer D wrong because root not shared.
link ref: https://aws.amazon.com/elasticache/

364.Explain
Answer A correct because SQS for async message passing.
Answer B wrong because Cognito auth.
Answer C wrong because Kinesis streaming.
Answer D correct because SNS for pub/sub.
Answer E wrong because ElastiCache caching.
link ref: https://aws.amazon.com/sqs/

365.Explain
Answer A wrong because same key consistency bad.
Answer B correct because delete root keys secure.
Answer C wrong because unused keys risk.
Answer D wrong because embed insecure.
Answer E correct because roles least privilege.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html

366.Explain
Answer A wrong because signature for CLI.
Answer B wrong because configure stores keys, insecure.
Answer C correct because role on instance provides creds.
Answer D wrong because params expose keys.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

367.Explain
Answer A wrong because remove ALB loses benefits.
Answer B wrong because Classic LB no X-Forwarded-For list.
Answer C correct because app inspects X-Forwarded-For for real IP.
Answer D wrong because custom header requires client change.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/x-forwarded-headers.html

368.Explain
Answer A wrong because CLI disassociate not exist.
Answer B wrong because AWS CLI no disassociate.
Answer C wrong because policy not for disassociate.
Answer D correct because recreate without RDS.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.db.html

369.Explain
Answer A correct because change not in master no trigger.
Answer B correct because earlier failure stops pipeline.
Answer C wrong because CodePipeline not cluster.
Answer D wrong because config correct assumed.
Answer E wrong because permissions ok assumed.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/troubleshooting.html

370.Explain
Answer A wrong because user pool not for notifications.
Answer B wrong because SyncCallback not exist.
Answer C wrong because stream for analysis.
Answer D correct because push sync with role notifies devices.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/push-sync.html

371.Explain
Answer A wrong because API Gateway S3 static.
Answer B wrong because Lambda Dynamo serverless.
Answer C correct because EC2 with Aurora for LAMP.
Answer D wrong because Cognito RDS auth + DB.
Answer E wrong because ECS EBS container.
link ref: https://aws.amazon.com/ec2/

372.Explain
Answer A correct because long polling reduces empty responses, minimal delay.
Answer B wrong because compress not delay.
Answer C wrong because short polling more requests.
Answer D wrong because split payload not help.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html

373.Explain
Answer A wrong because images to EBS local.
Answer B correct because S3 for both, shared.
Answer C wrong because S3 images, local disks not shared.
Answer D wrong because local images not shared.
link ref: https://aws.amazon.com/s3/

374.Explain
Answer A wrong because SNS sync.
Answer B wrong because SNS async.
Answer C correct because stream sync trigger.
Answer D wrong because async not guarantee order.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.html

375.Explain
Answer A correct because PATH needed for CLI.
Answer B wrong because access denied different error.
Answer C wrong because creds after configure.
Answer D wrong because script mode unrelated.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

376.Explain
Answer A wrong because fleet fixed, not auto-scale.
Answer B correct because Auto Scaling with queue depth scales fleet.
Answer C wrong because Kinesis with Lambda batch, but not for fraud time.
Answer D wrong because DynamoDB Streams with Lambda, but not for long process.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-using-sqs-queue.html

377.Explain
Answer A wrong because LC_ALL locale, not env limit.
Answer B wrong because Cognito not for env vars.
Answer C wrong because S3 not for env vars.
Answer D correct because Parameter Store stores large env vars.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

378.Explain
Answer A wrong because InvalidateCache not API.
Answer B wrong because endpoint custom.
Answer C correct because Cache-Control header invalidates.
Answer D wrong because query param not standard.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html

379.Explain
Answer A wrong because CloudWatch Lambda not for S3 events.
Answer B correct because S3 Event to Lambda real-time.
Answer C wrong because EC2 cron managed.
Answer D wrong because EMR big data.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-event-types-and-destinations.html

380.Explain
Answer A wrong because Swagger with Beanstalk not serverless.
Answer B wrong because CodeDeploy not serverless.
Answer C correct because SAM inline Swagger.
Answer D correct because SAM references Swagger file.
Answer E wrong because inline in Lambda not API.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html

381.Explain
Answer A wrong because change existing creates thumbnails but impacts upload time.
Answer B wrong because async invoke still on upload path.
Answer C correct because S3 event triggers separate thumbnail Lambda, no impact.
Answer D wrong because SQS scheduled complex.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html

382.Explain
Answer A wrong because update function URL changes endpoint.
Answer B wrong because phased not in API Gateway.
Answer C correct because new stage v2 keeps old clients on v1.
Answer D wrong because CloudFront for CDN.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html

383.Explain
Answer A correct because Cognito user pools with custom authorizer for JWT.
Answer B wrong because custom broker complex.
Answer C wrong because DynamoDB with STS insecure.
Answer D wrong because RDS for creds bad practice.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html

384.Explain
Answer A wrong because root standard.
Answer B wrong because bin binaries.
Answer C wrong because ebextension subfolder.
Answer D correct because .ebextensions for configs.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html

385.Explain
Answer A wrong because more RAM increases CPU but connection is bottleneck.
Answer B wrong because DB size not connections.
Answer C correct because global connection reuse reduces init time.
Answer D wrong because DynamoDB no pooling needed.
link ref: https://docs.aws.amazon.com/lambda/latest/operatorguide/connection-reuse.html

386.Explain
Answer A wrong because region not CORS.
Answer B wrong because same bucket not required.
Answer C wrong because port 80 security unrelated.
Answer D correct because CORS enables cross-bucket access.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors.html

387.Explain
Answer A wrong because user id prefixes not optimal for PUTs.
Answer B wrong because timestamps sequential hotspots.
Answer C wrong because file hashes for files, but folders for prefixes.
Answer D correct because hex hashes on folders distribute PUT requests.
link ref: https://aws.amazon.com/premiumsupport/knowledge-center/s3-request-limit-avoid/
