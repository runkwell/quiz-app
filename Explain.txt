1.Explain
Answer A wrong because ElastiCache is an in-memory caching service that optimizes read operations, not S3 PUTs which are write operations to object storage.
Answer B wrong because CodeDeploy deployments involve orchestration and rolling updates; ElastiCache does not influence deployment latency.
Answer C correct because ElastiCache caches frequently accessed data in memory, reducing database load for read-heavy workloads to improve latency and throughput.
Answer D wrong because CodeCommit branch merges are version control operations handled by Git; caching is irrelevant.
Answer E correct because ElastiCache can cache results of compute-intensive operations or intermediate data, offloading the database and speeding up repeated computations.
link ref: https://aws.amazon.com/elasticache/faqs/

2.Explain
Answer A correct because ElastiCache (Redis or Memcached) is an in-memory key-value store for caching.
Answer B wrong because SNS is a pub/sub messaging service for notifications, not a key-value store.
Answer C correct because DynamoDB is a NoSQL database supporting key-value and document data models.
Answer D wrong because SWF (Simple Workflow Service) orchestrates workflows, not stores key-value data.
Answer E correct because S3 is an object storage service where objects are addressed by keys (object names).
link ref: https://aws.amazon.com/products/databases/

3.Explain
Answer A wrong because account placement affects resource sharing but not header forwarding in ALB-Lambda integration.
Answer B wrong because request body size limits (1MB for sync) are unrelated to header handling.
Answer C wrong because Base64 encoding is for binary data in integrations, not enabling multi-value headers.
Answer D correct because ALB supports multi-value headers via a listener rule flag, allowing multiple values to be passed to Lambda.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/lambda-functions.html

4.Explain
Answer A wrong because writing to cache first risks stale data and violates strong consistency.
Answer B wrong because cache expiration delays updates, not ensuring immediate consistency.
Answer C wrong because write-through (simultaneous) can fail if cache write succeeds but backend fails.
Answer D correct because write-behind (backend first, invalidate cache) ensures consistency while allowing responsive reads until invalidation.
link ref: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Strategies.html

5.Explain
Answer A wrong because VPN/VPC endpoint secures the network path but does not encrypt the data payload in transit (relies on HTTPS).
Answer B correct because client-side encryption with KMS encrypts data before upload over HTTPS, securing transit.
Answer C wrong because SSE-KMS is for at-rest encryption after upload.
Answer D correct because SSL/TLS (HTTPS) encrypts data during transfer to S3.
Answer E wrong because SSE-S3 is for at-rest encryption.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html

6.Explain
Answer A wrong because SSE-S3 uses AWS-managed keys without user-specific audit trails.
Answer B correct because SSE-KMS uses customer-managed keys with CloudTrail auditing for key usage.
Answer C wrong because client-side symmetric keys lack AWS-managed auditing.
Answer D wrong because client-side KMS still requires app-level auditing, not automatic like SSE-KMS.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

7.Explain
Answer A correct because cross-account IAM roles allow secure temporary access without sharing long-lived credentials.
Answer B wrong because S3 replication and Lambda events are for data sync, not API access.
Answer C wrong because per-account deployments increase overhead and blast radius.
Answer D wrong because access keys are long-lived and insecure for cross-account use.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_cross-account-with-roles.html

8.Explain
Answer A wrong because CodeDeploy requires bundles in accessible storage like S3, not local.
Answer B correct because S3 is the standard storage for CodeDeploy bundles from on-premises.
Answer C wrong because CodeCommit triggers builds, not direct deployments.
Answer D wrong because CodeBuild builds artifacts, not deploys to EC2.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-config-files.html

9.Explain
Answer A correct because encrypted EBS volumes provide at-rest encryption with minimal performance impact (hardware-accelerated).
Answer B wrong because S3 adds latency for frequent compute access.
Answer C wrong because custom algorithms add CPU overhead.
Answer D wrong because ephemeral disks lose data on stop; AMI root doesn't encrypt attached volumes.
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html

10.Explain
Answer A wrong because prefixes help throughput but not global latency.
Answer B wrong because ElastiCache caches app data, not ideal for static images.
Answer C correct because CloudFront is a CDN that caches S3 content edge-located, reducing global latency.
Answer D wrong because rate limits are per prefix; issue is distribution, not limits.
link ref: https://aws.amazon.com/cloudfront/features/

11.Explain
Answer A wrong because default S3 KMS is SSE, not client-side.
Answer B wrong because S3 managed keys are SSE; GenerateDataKey is client-side.
Answer C correct because GenerateDataKey provides a data key for client-side encryption in Lambda before S3 upload.
Answer D wrong because custom KMS needs explicit policy; GenerateDataKey is the mechanism.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/create-data-keys.html

12.Explain
Answer A wrong because versioning tracks changes, not CORS.
Answer B wrong because public access exposes, but CORS is for browser cross-origin.
Answer C wrong because Content-MD5 is for integrity checks.
Answer D correct because CORS policy allows the website domain to access fonts in another bucket.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors.html

13.Explain
Answer A wrong because sam init initializes new projects.
Answer B wrong because sam validate syntax-checks templates.
Answer C correct because sam build packages dependencies and code.
Answer D correct because sam deploy creates/updates the stack.
Answer E wrong because sam publish shares templates.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference.html

14.Explain
Answer A wrong because all-at-once stops all instances, causing downtime.
Answer B wrong because rolling replaces in batches, reducing capacity temporarily.
Answer C correct because rolling with additional batch launches extras to maintain full capacity during update.
Answer D wrong because immutable launches new fleet, not using existing instances.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

15.Explain
Answer A correct because instance metadata endpoint provides public IP at /latest/meta-data/public-ipv4.
Answer B wrong because userdata is user-provided script/config.
Answer C wrong because ifconfig shows local IPs, not public.
Answer D wrong because ipconfig is Windows; EC2 typically Linux.
link ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html

16.Explain
Answer A wrong because single API caches all stages constantly, high cost.
Answer B wrong because three APIs triple management/cost.
Answer C wrong because separate accounts add complexity/cost.
Answer D correct because cache is billed by size/time; enable only for active use in dev/test.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html

17.Explain
Answer A wrong because retries handle failures, not optimize reads.
Answer B wrong because Multi-AZ is for failover, not read scaling.
Answer C correct because read replicas offload read queries; update connection for reads.
Answer D wrong because EC2 replica is self-managed, complex.
link ref: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html

18.Explain
Answer A correct because event-driven processes data on arrival via triggers like Streams.
Answer B wrong because client-server not for near-real-time processing.
Answer C wrong because fan-out distributes, not processes.
Answer D wrong because schedule-driven is batch nightly.
link ref: https://aws.amazon.com/event-driven-architecture/

19.Explain
Answer A wrong because EC2 size doesn't affect DynamoDB throttling.
Answer B wrong because RCUs for reads; issue is writes (ProvisionedThroughputExceeded).
Answer C correct because exponential backoff retries throttled requests without overwhelming.
Answer D wrong because increasing frequency exacerbates throttling.
Answer E correct because on-demand auto-scales capacity, avoiding provisioned limits.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-ddb-rate-limit.html

20.Explain
Answer A wrong because SSE-S3 uses AWS keys, no customer control.
Answer B wrong because SSE-C requires providing keys per request.
Answer C correct because SSE-KMS uses AWS-managed CMK with customer control/audit.
Answer D wrong because client-side requires app encryption management.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

21.Explain
Answer A wrong because KCL allows multiple consumers per shard, but max instances = shards without standby.
Answer B correct because after resharding to 6 shards, max 6 instances (one primary per shard).
Answer C wrong because initial 4, but post-reshard 6.
Answer D wrong because not 1.
link ref: https://docs.aws.amazon.com/streams/latest/dev/amazon-kinesis-using-sdk-java-add-shard.html

22.Explain
Answer A wrong because Lambda is compute, needs backend.
Answer B wrong because S3 storage, no sync logic.
Answer C wrong because DynamoDB needs backend app.
Answer D correct because Cognito Sync handles device sync without backend.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-sync.html

23.Explain
Answer A correct because zip upload/deploy via console standard.
Answer B wrong because tar/console new version, CLI update mismatched.
Answer C wrong because tar console possible but not selected.
Answer D correct because zip CLI create/update.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/applications-sourcebundle.html

24.Explain
Answer A correct because /tmp for local caching in Lambda.
Answer B wrong because timeout increase not cache.
Answer C wrong because ELB not Lambda.
Answer D wrong because S3 adds latency.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html

25.Explain
Answer A wrong because batch writes affect writes.
Answer B correct because GSI projects attributes, reduces RCU.
Answer C wrong because backoff for throttling.
Answer D wrong because ALB HTTP.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

26.Explain
Answer A wrong because validation input.
Answer B wrong because ARN invocation.
Answer C wrong because integration proxy.
Answer D correct because mapping template query to args.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html

27.Explain
Answer A wrong because roles better.
Answer B wrong because shared insecure.
Answer C correct because unique users keys secure local.
Answer D wrong because Cognito app.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html

28.Explain
Answer A wrong because strong more.
Answer B correct because strong 2x RCU eventual.
Answer C wrong because more not less.
Answer D wrong because fixed 2x.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html

29.Explain
Answer A correct because console upload deploy.
Answer B wrong because eb init setup.
Answer C wrong because terminate destructive.
Answer D wrong because ebextensions config.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/applications-versions.html

30.Explain
Answer A correct because condition authenticated update user_name.
Answer B wrong because no web identity.
Answer C wrong because broad access.
Answer D wrong because misses condition.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_examples_dynamodb_items.html

31.Explain
Answer A wrong because no traffic split.
Answer B correct because alias 10% shift safe.
Answer C wrong because ARN change risky.
Answer D wrong because multiple aliases overkill.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html

32.Explain
Answer A wrong because single env no independent scale.
Answer B correct because separate envs scale independent.
Answer C wrong because multiple HTTP one background.
Answer D wrong because multiple background one HTTP.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.environments.html

33.Explain
Answer A correct because changesets preview impacts.
Answer B wrong because stack policies prevent.
Answer C wrong because Metadata info.
Answer D wrong because Resources define.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html

34.Explain
Answer A wrong because different functions management.
Answer B wrong because stages versions, aliases no endpoint change.
Answer C correct because aliases point versions, no API change.
Answer D wrong because tags routing no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html

35.Explain
Answer A wrong because certs incoming.
Answer B wrong because allows, need deny.
Answer C wrong because HTTPS redirect incoming.
Answer D correct because deny non-secure enforces HTTPS.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html

36.Explain
Answer A wrong because SQS/SNS messaging.
Answer B correct because ELB EC2 REST.
Answer C wrong because ElastiCache/Elasticsearch storage/search.
Answer D correct because API Gateway Lambda serverless REST.
Answer E wrong because S3/CloudFront static.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html

37.Explain
Answer A correct because /tmp ephemeral temp.
Answer B wrong because EFS persistent slow.
Answer C wrong because EBS block.
Answer D wrong because S3 object latency.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html

38.Explain
Answer A wrong because EC2 NoSQL self.
Answer B correct because ElastiCache cache-aside profiles.
Answer C wrong because RDS write-through relational.
Answer D wrong because write-through populates, cache-aside reads better.
link ref: https://aws.amazon.com/elasticache/

39.Explain
Answer A wrong because VM Import migration self.
Answer B wrong because Lightsail simple not dynamic.
Answer C correct because Beanstalk manages deployment.
Answer D wrong because S3/CloudFront static.
link ref: https://aws.amazon.com/elasticbeanstalk/

40.Explain
Answer A correct because context request ID logging.
Answer B wrong because event no ID, file less reliable.
Answer C wrong because event ID console standard.
Answer D wrong because context ID file less.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/nodejs-logging.html

41.Explain
Answer A correct because EC2 role assume AccessPII.
Answer B wrong because direct no assumption.
Answer C wrong because AWS API temp.
Answer D correct because AssumeRole temp.
Answer E wrong because GetSessionToken users.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

42.Explain
Answer A wrong because event source no trace API.
Answer B wrong because ALB logs no DynamoDB.
Answer C wrong because limit invocations no timing.
Answer D correct because X-Ray traces timings.
link ref: https://aws.amazon.com/xray/

43.Explain
Answer A wrong because Multi-AZ writes/HA.
Answer B correct because replica offload reads.
Answer C wrong because ElastiCache buffers writes, reads issue.
Answer D wrong because DynamoDB overkill.
link ref: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html

44.Explain
Answer A wrong because BatchWriteItem no transactional.
Answer B correct because TransactWriteItems all-or-nothing.
Answer C wrong because SQS messaging.
Answer D wrong because Aurora sync complex.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html

45.Explain
Answer A wrong because S3 Lambda indirect.
Answer B wrong because Kinesis Lambda overkill.
Answer C wrong because API role no creds.
Answer D correct because PutMetricData IAM role EC2.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

46.Explain
Answer A wrong because CLI no large.
Answer B correct because Extended Library S3 >256KB.
Answer C wrong because EBS block.
Answer D wrong because EFS file CLI no.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-s3-messages.html

47.Explain
Answer A wrong because X-Ray tracing no metrics graph.
Answer B correct because custom PutMetricData graph CloudWatch.
Answer C wrong because S3 Kinesis complex.
Answer D wrong because DynamoDB CloudFront mismatch.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

48.Explain
Answer A correct because package modules reduce size cold start.
Answer B wrong because DynamoDB vs RDS bottleneck.
Answer C correct because connection outside handler reuse.
Answer D wrong because custom pooling unnecessary.
Answer E wrong because local caching no connection.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

49.Explain
Answer A wrong because SES email, metric SNS alert.
Answer B wrong because API-error built-in, custom SNS.
Answer C wrong because SES no alert.
Answer D correct because custom metric CloudWatch SNS.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html

50.Explain
Answer A wrong because multiple pipelines complex.
Answer B correct because approval pauses manual.
Answer C wrong because disable transition manual.
Answer D wrong because disable stage no workflow.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/approvals.html

51.Explain
Answer A correct because Redis Cluster HA uptime.
Answer B wrong because EC2 Redis self uptime.
Answer C wrong because Memcached no persistence.
Answer D wrong because Redshift analytics.
link ref: https://aws.amazon.com/elasticache/redis/

52.Explain
Answer A wrong because memory no time.
Answer B wrong because same bucket possible.
Answer C correct because timeout 15min, 500s >3s default.
Answer D wrong because Java fine.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html

53.Explain
Answer A wrong because SSL transit.
Answer B wrong because KCL consumer no encrypt.
Answer C wrong because Lambda after rest.
Answer D correct because server-side Kinesis at rest.
link ref: https://docs.aws.amazon.com/streams/latest/dev/server-side-encryption.html

54.Explain
Answer A wrong because Lambda compute.
Answer B correct because Cognito SAML mobile.
Answer C wrong because IAM internal.
Answer D wrong because EC2 server.
link ref: https://aws.amazon.com/cognito/

55.Explain
Answer A wrong because SNS notification.
Answer B wrong because NetworkIn bytes.
Answer C wrong because CloudFront CDN.
Answer D correct because custom metric users scaling.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-target-tracking.html

56.Explain
Answer A wrong because API manual.
Answer B wrong because standard CloudFormation Lambda.
Answer C correct because SAM simplifies serverless.
Answer D wrong because bash no automated.
link ref: https://aws.amazon.com/serverless/sam/

57.Explain
Answer A wrong because encryption no restrict.
Answer B correct because item-level primary key conditions.
Answer C wrong because SQS complexity.
Answer D wrong because client discard inefficient.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/specifying-conditions.html

58.Explain
Answer A wrong because STS temp no guest.
Answer B wrong because Directory AD.
Answer C correct because Cognito unauth roles guest.
Answer D wrong because SAML federated.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html

59.Explain
Answer A wrong because no compile.
Answer B correct because package uploads S3 modifies template.
Answer C wrong because zip template no.
Answer D wrong because no command.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-cli-package.html

60.Explain
Answer A wrong because unzip size no.
Answer B wrong because compression no unzip.
Answer C correct because smaller functions size.
Answer D wrong because double zip no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html

61.Explain
Answer A correct because DynamoDB persistent sessions.
Answer B wrong because SQS queue.
Answer C wrong because local no across.
Answer D wrong because SQLite no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

62.Explain
Answer A wrong because GSI queries.
Answer B correct because backoff throttling.
Answer C wrong because immediate retry worse.
Answer D wrong because UpdateItem writes.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html

63.Explain
Answer A wrong because immutable replacement.
Answer B wrong because rolling reduces.
Answer C wrong because all at once down.
Answer D correct because rolling batch capacity cost.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

64.Explain
Answer A wrong because legibility no performance.
Answer B correct because connection reuse cold start.
Answer C wrong because error unrelated.
Answer D wrong because new instance per invocation bad reuse.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

65.Explain
Answer A wrong because Data Pipeline ETL.
Answer B wrong because SNS/SQS messaging.
Answer C wrong because EMR big data.
Answer D correct because Step Functions state.
link ref: https://aws.amazon.com/step-functions/

66.Explain
Answer A wrong because single profile no.
Answer B wrong because roles per service task no.
Answer C wrong because group cluster no per task.
Answer D correct because roles per task least.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html

67.Explain
Answer A correct because Step parallel vendors.
Answer B wrong because SQS worker sequential.
Answer C wrong because Lambda async no join.
Answer D wrong because Events no orchestration.
link ref: https://aws.amazon.com/step-functions/

68.Explain
Answer A wrong because String scan inefficient.
Answer B wrong because container scan costly.
Answer C wrong because Date GSI minute over.
Answer D correct because TTL Number auto-delete cost-free.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-how-to.html

69.Explain
Answer A wrong because support last.
Answer B wrong because CLI no throttling.
Answer C wrong because analyze no fix.
Answer D correct because backoff standard.
link ref: https://docs.aws.amazon.com/general/latest/gr/api-retries.html

70.Explain
Answer A wrong because SNS SQS no concurrent.
Answer B wrong because FIFO ordered cost no concurrent.
Answer C wrong because Firehose delivery no processing.
Answer D correct because Streams multiple consumers sharded cost.
link ref: https://aws.amazon.com/kinesis/data-streams/

71.Explain
Answer A correct because appspec root CodeDeploy.
Answer B wrong because bin binaries.
Answer C wrong because S3 no structure.
Answer D wrong because config separate.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file.html

72.Explain
Answer A correct because Firehose ingest S3 scalable.
Answer B wrong because Acceleration transfer no ingest.
Answer C wrong because SQS queue no S3.
Answer D wrong because SNS notification.
link ref: https://aws.amazon.com/kinesis/data-firehose/

73.Explain
Answer A wrong because install runtime time.
Answer B wrong because package libs.
Answer C wrong because S3 reference download.
Answer D correct because Layers share libs time.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html

74.Explain
Answer A correct because parallel scans rate minimize time overload.
Answer B wrong because sequential slower.
Answer C wrong because RCU during scan temporary.
Answer D wrong because eventual accuracy no optimization.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html

75.Explain
Answer A correct because CloudFront caches S3 global.
Answer B wrong because replication durability.
Answer C wrong because logs deletion no.
Answer D wrong because lifecycle management.
Answer E correct because random prefixes distribute.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance.html

76.Explain
Answer A correct because API Gateway JSON to XML SOAP.
Answer B wrong because ALB JSON no transform.
Answer C wrong because ALB XML no JSON input.
Answer D wrong because transform XML no input JSON.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html

77.Explain
Answer A wrong because S3 encryption no rate.
Answer B correct because KMS API limits latency.
Answer C wrong because client algo no.
Answer D wrong because alias optional.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/limits.html

78.Explain
Answer A correct because rolling batches minimal outage existing.
Answer B wrong because all at once outage.
Answer C wrong because additional batch adds.
Answer D wrong because immutable replaces.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

79.Explain
Answer A wrong because reverse no FIFO.
Answer B wrong because exact order shard.
Answer C correct because FIFO shard no across.
Answer D wrong because no options getRecords.
link ref: https://docs.aws.amazon.com/streams/latest/dev/kinesis-using-sdk-java-get-records.html

80.Explain
Answer A wrong because Lambda reactive no prevent.
Answer B correct because policy prevent no encryption header.
Answer C wrong because Events after no prevent.
Answer D wrong because prevent with header no require.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingServerSideEncryption.html

81.Explain
Answer A correct because unique MessageGroupId order per sender.
Answer B wrong because dedup duplicates no order.
Answer C wrong because message level group FIFO.
Answer D wrong because content dedup no order.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagegroupid-property.html

82.Explain
Answer A wrong because KMS encryption.
Answer B correct because Cognito auth cross-platform preferences.
Answer C wrong because Directory AD.
Answer D wrong because IAM internal.
link ref: https://aws.amazon.com/cognito/

83.Explain
Answer A wrong because tags no env vars.
Answer B wrong because hardcore no flexible.
Answer C correct because env vars inject per env.
Answer D wrong because separate duplicate.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html

84.Explain
Answer A wrong because Cognito app auth.
Answer B wrong because keys mail insecure.
Answer C correct because AssumeRole temp cross-account.
Answer D wrong because SSH no AWS API.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html

85.Explain
Answer A wrong because SDK annotation app.
Answer B correct because daemon EC2 traces.
Answer C wrong because daemon CloudWatch no X-Ray.
Answer D wrong because SDK code daemon EC2.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon.html

86.Explain
Answer A wrong because user creds repo insecure.
Answer B wrong because inject user data insecure.
Answer C wrong because policy metrics no instances.
Answer D correct because role ASG secure.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

87.Explain
Answer A wrong because starRating uneven.
Answer B correct because reviewID unique even.
Answer C wrong because comment poor hashing.
Answer D wrong because productID hot popular.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html

88.Explain
Answer A correct because condition ${aws:username}.
Answer B wrong because principal who.
Answer C wrong because variables ${aws:username}.
Answer D wrong because resource what.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html

89.Explain
Answer A wrong because SSE-S3 AWS key.
Answer B correct because SSE-KMS own CMK AWS.
Answer C wrong because client-side own.
Answer D wrong because roles/policies access no encrypt.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/services-s3.html

90.Explain
Answer A wrong because CLI group no.
Answer B wrong because metadata roles no policies.
Answer C wrong because STS token describe no Kinesis.
Answer D correct because --dry-run simulates get.
Answer E correct because simulator tests policy.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_testing.html

91.Explain
Answer A correct because CodeCommit pipeline SNS failures.
Answer B wrong because GitHub SES no AWS.
Answer C wrong because GitHub CloudWatch no pipeline.
Answer D wrong because CodeCommit CloudWatch no SNS.
link ref: https://aws.amazon.com/codepipeline/

92.Explain
Answer A correct because ChangeMessageVisibility increase timeout process delete.
Answer B wrong because DeleteQueue entire queue.
Answer C wrong because decrease timeout visible sooner re-process.
Answer D wrong because no DeleteMessageVisibility API.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html

93.Explain
Answer A wrong because DynamoDB/SNS manual MFA.
Answer B correct because Cognito native MFA.
Answer C wrong because Directory AD no MFA app.
Answer D wrong because IAM MFA console/CLI.
link ref: https://aws.amazon.com/cognito/

94.Explain
Answer A correct because eventual 5 RCU 4KB max throughput.
Answer B wrong because strong 10 RCU.
Answer C wrong because 15 RCU 1KB less data.
Answer D wrong because strong more RCU.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

95.Explain
Answer A wrong because compression/versioning no growth.
Answer B wrong because replication another bucket.
Answer C correct because logging same bucket loop exponential.
Answer D wrong because IA moves no grow.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerLogs.html

96.Explain
Answer A correct because ECS task role secure creds.
Answer B wrong because AssumeRole instance complex.
Answer C wrong because env vars insecure.
Answer D wrong because file insecure.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html

97.Explain
Answer A wrong because buildspec future no current.
Answer B wrong because X-Ray tracing no build logs.
Answer C correct because history logs failed phases.
Answer D wrong because local no AWS env.
link ref: https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html

98.Explain
Answer A wrong because order incorrect.
Answer B correct because in-place stop before after start.
Answer C wrong because validate after.
Answer D wrong because validate no order.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html

99.Explain
Answer A wrong because KMS data.
Answer B correct because STS decode IAM errors.
Answer C wrong because open source no AWS format.
Answer D wrong because IAM no API.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_DecodeAuthorizationMessage.html

100.Explain
Answer A wrong because S3 signed manual.
Answer B wrong because metadata insecure.
Answer C wrong because DynamoDB client complex.
Answer D correct because Parameter Store secure effort.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

1101.Explain
Answer A wrong because Elastic Load Balancer logs capture load balancer-specific events like HTTP requests/responses, but not S3 API calls like DeleteBucket, which are service-level actions.
Answer B wrong because application logs in CloudWatch Logs would show app-generated errors (e.g., from SDK calls), but not the underlying AWS service events like bucket deletion; they might show the error but not the root cause event.
Answer C wrong because AWS X-Ray is for tracing application requests and performance, not for auditing or alarming on management API events like DeleteBucket; it doesn't capture CloudTrail-level audit logs.
Answer D correct because AWS CloudTrail records all API calls, including management actions like DeleteBucket, providing a chronological audit trail to identify who/when deleted the bucket, starting root cause analysis.
link ref: https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html

102.Explain
Answer A wrong because specifying keys as parameters for each command is insecure (exposes in scripts/logs) and inefficient (manual per call), violating least privilege and credential management best practices.
Answer B correct because `aws configure` stores the access key ID and secret access key in the CLI config file (~/.aws/credentials), allowing the CLI to use IAM permissions automatically for all commands without per-command input.
Answer C wrong because IAM uses access keys, not username/password; passwords are for console federation, and passing them is insecure and unsupported for CLI.
Answer D wrong because IAM roles are for AWS services/instances (e.g., EC2), not local CLI on development servers; CLI requires configured credentials.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html

103.Explain
Answer A correct because Lambda automatically scales out by provisioning additional execution environments concurrently to handle event bursts like S3 notifications, ensuring high availability without sequential queuing.
Answer B wrong because Lambda processes invocations asynchronously and concurrently by default; sequential handling would require custom queuing, which isn't the case for S3 events.
Answer C wrong because S3 event notifications trigger one invocation per event (per image), not batching multiple into a single execution unless configured via batch size in event source mapping (not applicable here).
Answer D wrong because Lambda doesn't dynamically add compute per execution; memory allocation sets CPU proportionally, but scaling is horizontal (more instances), not vertical per invocation.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-scaling.html

104.Explain
Answer A wrong because Global Secondary Indexes (GSIs) add query flexibility but don't reduce read latency or provisioning needs; they consume additional capacity and may increase costs.
Answer B wrong because S3 is object storage with higher latency (ms to s) unsuitable for sub-ms trading; Transfer Acceleration speeds global uploads, not low-latency reads.
Answer C wrong because retries with backoff mitigate throttling but don't address root latency from data retrieval or over-provisioning costs during spikes.
Answer D correct because DynamoDB Accelerator (DAX) is an in-memory cache that provides sub-ms reads for frequently accessed data, reducing direct DynamoDB calls and allowing lower provisioned capacity while handling spikes via caching.
link ref: https://aws.amazon.com/dynamodb/dax/

105.Explain
Answer A wrong because Lambda automatically generates logs for invocations (e.g., start/end times) even without explicit statements if the runtime supports it; explicit logs (console.log) add detail but aren't required for basic logging.
Answer B wrong because CloudWatch Logs is a destination, not a source; Lambda pushes logs without needing a trigger.
Answer C correct because the execution role requires logs:CreateLogGroup, logs:CreateLogStream, and logs:PutLogEvents permissions to write to CloudWatch Logs; missing these prevents log generation.
Answer D wrong because Lambda auto-creates log groups/streams per function if permissions allow; no manual target needed.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html

106.Explain
Answer A wrong because view access is separate (via IAM policies like xray:Get*); if traces reach X-Ray, the issue is sending, not viewing.
Answer B correct because the X-Ray daemon must run on EC2 to collect/send traces from the host; without it, app instrumentation (SDK) can't forward traces.
Answer C wrong because endpoint misconfig would affect local testing too if same code; assumes correct in app but deployment-specific issue.
Answer D wrong because BatchGetTraces/GetTraceGraph are for querying traces (viewing), not sending; the problem is traces not available (not sent).
Answer E correct because the instance role needs xray:PutTraceSegments (send traces) and xray:PutTelemetryRecords (send metadata) to allow the daemon to write to X-Ray.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon.html

107.Explain
Answer A wrong because DynamoDB stores data but doesn't generate unique cross-device identities; requires custom logic for uniqueness.
Answer B wrong because IAM access key IDs are for AWS access, not app user identities; storing without secrets is insecure and not scalable.
Answer C correct because Cognito developer-authenticated identities provide unique, persistent IDs for users across devices, with temporary AWS credentials for access.
Answer D wrong because IAM users/roles are for AWS services, not app end-users; resource IDs aren't suitable for app logic.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/developer-authenticated-identities.html

108.Explain
Answer A wrong because get-template/execute-change-set is for existing stacks, not launching new templatized serverless apps.
Answer B wrong because validate/create-change-set prepares but doesn't deploy/package serverless specifics.
Answer C correct because `package` bundles the template/artifacts to S3, then `deploy` creates the CloudFormation stack for serverless resources.
Answer D wrong because create/update-stack assumes template is already packaged; skips bundling step.
link ref: https://docs.aws.amazon.com/cli/latest/reference/cloudformation/package.html

109.Explain
Answer A wrong because inline policies are embedded in the role and evaluated with it; wouldn't bypass restrictions.
Answer B correct because managed policies can be attached to multiple principals; if a broader managed policy is attached (overriding restrictive), it allows access despite role assumption.
Answer C wrong because CLI corruption would affect all commands, not just S3 writes.
Answer D wrong because credential chain prefers env vars first (used here), then shared credentials, instance profile last; but env vars take precedence, bypassing role.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-precedence.html

110.Explain
Answer A correct because S3 PUT overwrites are eventually consistent in the same partition; reads may see old version until propagated (seconds).
Answer B wrong because metadata labeling doesn't affect consistency; versioning would, but not mentioned.
Answer C wrong because new object PUTs are immediately consistent, only overwrites/modifies are eventual.
Answer D wrong because no explicit "latest" parameter; consistency model dictates behavior.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance.html

111.Explain
Answer A wrong because KMS Encrypt is for small payloads (<4KB); videos are large, requiring data keys.
Answer B wrong because custom library keys aren't AWS-managed; lacks integration/rotation.
Answer C correct because GenerateDataKey provides a per-file data key for envelope encryption; encrypt video with data key, store encrypted key/data for large payloads.
Answer D wrong because SSE-KMS is server-side after upload, not app-level prior encryption.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/services-s3.html

112.Explain
Answer A wrong because CloudTrail logs API calls, not async invocation details/failures.
Answer B correct because Dead Letter Queues (DLQ) capture unprocessed events after retries; SQS DLQ allows inspection of failed messages.
Answer C wrong because SWF is workflow orchestration, not for Lambda async failures.
Answer D wrong because Config tracks resource configs, not event processing.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq

113.Explain
Answer A wrong because stage throttling is global, not per-user; creating stages per user is high overhead.
Answer B wrong because CloudWatch filter/alarm/Lambda is custom/complex for throttling.
Answer C wrong because alarms deny but not per-user; user-specific alarms scale poorly.
Answer D correct because usage plans associate API keys with rate/burst limits; custom plans per package with low management.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html

114.Explain
Answer A wrong because SQS queues messages but doesn't orchestrate sequence/parallel.
Answer B wrong because activities are for external tasks; Lambda integration is via states.
Answer C wrong because SNS fans out but no sequencing.
Answer D correct because Step Functions state machines define workflows with parallel/sequence branches for Lambda invocations.
link ref: https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html

115.Explain
Answer A wrong because ConsistentRead ensures fresh data but not atomic transactions across items.
Answer B wrong because Memcached lacks transaction support.
Answer C correct because Aurora MySQL supports ACID transactions within blocks for atomic updates.
Answer D correct because DynamoDB TransactWriteItems/TransactGetItems provide atomic, consistent operations.
Answer E wrong because Redshift is analytics, limited transaction support.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html

116.Explain
Answer A correct because Git CLI clone/commit/push in Lambda for CodeCommit integration.
Answer B wrong because SDK put_file direct, but Lambda runtime limits.
Answer C wrong because SDK no full Git ops.
Answer D wrong because API direct no Git.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-migrate-repository.html

117.Explain
Answer A wrong because env vars long-lived insecure.
Answer B wrong because file insecure.
Answer C correct because instance profile rotated secure.
Answer D wrong because options expose.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

118.Explain
Answer A wrong because keys code insecure.
Answer B wrong because policies users no scalable.
Answer C correct because Cognito auth/unauth roles.
Answer D wrong because IAM per user no.
Answer E correct because STS AssumeRole roles type.
link ref: https://aws.amazon.com/cognito/

119.Explain
Answer A wrong because VPC link private no auth.
Answer B wrong because pools groups auth.
Answer C correct because identity SAML condition sub.
Answer D wrong because unique roles no scalable.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html

120.Explain
Answer A wrong because zip Lambda direct.
Answer B wrong because X-Ray after.
Answer C correct because sam package bundles.
Answer D wrong because eb Beanstalk.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-package.html

121.Explain
Answer A wrong because SSE-S3 AWS no control.
Answer B correct because SSE-KMS own AWS.
Answer C wrong because client-side own.
Answer D wrong because roles access no encrypt.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

122.Explain
Answer A wrong because folder poll inefficient.
Answer B correct because S3 SQS decouple Lambda.
Answer C wrong because Gateway sync.
Answer D wrong because Step poll complex.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html

123.Explain
Answer A wrong because pods Kubernetes.
Answer B wrong because tasks volume share.
Answer C correct because one task containers share.
Answer D wrong because pods no ECS.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

124.Explain
Answer A correct because alarm CPU SNS.
Answer B wrong because Trail no CPU.
Answer C wrong because cron manual.
Answer D wrong because Lambda Trail mismatch.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html

125.Explain
Answer A wrong because role DB insecure.
Answer B correct because Secrets rotation.
Answer C wrong because S3 file insecure.
Answer D wrong because code no rotation.
link ref: https://aws.amazon.com/secrets-manager/

126.Explain
Answer A wrong because all once down.
Answer B wrong because rolling batch partial.
Answer C correct because new swap no down.
Answer D wrong because rolling gradual.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.CNAMESwap.html

127.Explain
Answer A wrong because lifecycle no auth.
Answer B correct because presigned timed.
Answer C wrong because SSE at rest.
Answer D wrong because policy temp no per doc.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html

128.Explain
Answer A correct because ResultPath error output.
Answer B wrong because InputPath null discard.
Answer C wrong because Retry error.
Answer D wrong because OutputPath full.
link ref: https://docs.aws.amazon.com/step-functions/latest/dg/concepts-error-handling.html

129.Explain
Answer A wrong because issue is throttling, not permissions. Ref:IAM Roles for EC2.
Answer B correct because retries with increasing delays (e.g., 1s, 2s, 4s) reduce load on AWS APIs. Boto3 supports this natively.
Answer C wrong because throttling is server-side limit, not network issue. Ref:EC2 Throttling Limits.
Answer D wrong because updates improve features but don't raise request limits. Ref:Boto3 Release Notes.
link ref: https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-throttling.html
	      https://boto3.amazonaws.com/v1/documentation/api/latest/guide/retries.html

130.Explain
Answer A correct because exports bucket name (e.g., { Export: { Name: "MyBucketExport" } }), imports via !ImportValue "MyBucketExport". Native and simple.
Answer B wrong because no such properties/functions exist.
Answer C wrong because Inefficient; adds complexity (e.g., Lambda) vs. native export.
Answer D wrong because Fn::Include no such intrinsic function.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/walkthrough-crossstackref.html
	      https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/intrinsic-function-reference-importvalue.html

131.Explain
Answer A correct because AfterInstall post permissions.
Answer B wrong because DownloadBundle download.
Answer C wrong because BeforeInstall pre.
Answer D wrong because ValidateService after.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html

132.Explain
Answer A wrong because Streams changes.
Answer B correct because DAX accelerates reads/writes.
Answer C wrong because global replication.
Answer D wrong because transactions consistency.
link ref: https://aws.amazon.com/dynamodb/dax/

133.Explain
Answer A correct because cloudformation package/deploy SAM.
Answer B correct because sam package/deploy.
Answer C wrong because s3/lambda no SAM.
Answer D wrong because serverlessrepo sharing.
Answer E wrong because zip/cloudformation no SAM.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-deploy.html

134.Explain
Answer A correct because pool users.
Answer B wrong because SNS manual.
Answer C correct because enable MFA pool.
Answer D wrong because IAM teams.
Answer E wrong because IAM console.
link ref: https://aws.amazon.com/cognito/

135.Explain
Answer A wrong because false disables roles.
Answer B wrong because false profile shared.
Answer C correct because true separate roles.
Answer D wrong because true profile shared.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html

136.Explain
Answer A wrong because CloudWatch custom no trace.
Answer B wrong because X-Ray trace CloudWatch no.
Answer C correct because X-Ray trace/analyze.
Answer D wrong because CloudWatch timestamps X-Ray no.
link ref: https://aws.amazon.com/xray/

137.Explain
Answer A correct because longer polling reduces calls.
Answer B wrong because scale no costs.
Answer C wrong because SNS push no polling.
Answer D wrong because FIFO costly.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html

138.Explain
Answer A wrong because Trail logs.
Answer B correct because X-Ray end-to-end.
Answer C wrong because Logs execution.
Answer D wrong because Flow network.
link ref: https://aws.amazon.com/xray/

139.Explain
Answer A wrong because list no deny overrides.
Answer B wrong because one no.
Answer C wrong because full deny.
Answer D correct because explicit deny role overrides allow.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html

140.Explain
Answer A wrong because count no retain.
Answer B wrong because disable no retain.
Answer C wrong because age no retain.
Answer D correct because Retention keeps bundle.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.as-versions.html

141.Explain
Answer A correct because no invalidate stale.
Answer B wrong because write-through updates.
Answer C wrong because provision no.
Answer D wrong because write ok.
link ref: https://aws.amazon.com/elasticache/

142.Explain
Answer A wrong because KMS no CodeCommit.
Answer B correct because helper HTTPS.
Answer C wrong because Manager SSL.
Answer D wrong because CloudHSM custom.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-https-unixes.html

143.Explain
Answer A wrong because logs/S3 no X-Ray.
Answer B wrong because CloudWatch trigger no.
Answer C correct because role enable tracing.
Answer D wrong because daemon runtime.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html

144.Explain
Answer A wrong because trust DynamoDB wrong.
Answer B correct because permissions DynamoDB trust EC2 PassRole.
Answer C wrong because permissions EC2 wrong.
Answer D wrong because GetRole no.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html

145.Explain
Answer A correct because install local zip all.
Answer B wrong because lib/zip dependency no.
Answer C wrong because install code runtime.
Answer D wrong because no LB_LIBRARY_PATH.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

146.Explain
Answer A wrong because identity pools auth.
Answer B correct because Cognito web social.
Answer C wrong because keys code insecure.
Answer D wrong because STS assume roles.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-integrating-amazon-cognito-with-web-and-mobile-apps.html

147.Explain
Answer A wrong because GetMetricData metrics no logs.
Answer B wrong because Trail API.
Answer C wrong because Events triggers.
Answer D correct because Logs agent EC2.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/QuickStartEC2Instance.html

148.Explain
Answer A wrong because DeleteItem conditional slow.
Answer B wrong because BatchWriteItem limited.
Answer C wrong because recursive slow.
Answer D correct because recreate daily temp.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.CreateTable.html

149.Explain
Answer A wrong because bucket no duplicates.
Answer B correct because Lambda retries duplicates.
Answer C wrong because no S3 outage.
Answer D wrong because intermittent no log duplicates.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-retries.html

150.Explain
Answer A wrong because Lambda compute.
Answer B wrong because X-Ray tracing.
Answer C wrong because SQS messaging.
Answer D correct because Gateway microservices.
link ref: https://aws.amazon.com/api-gateway/

151.Explain
Answer A correct because S3 CloudFront static.
Answer B wrong because EC2 self.
Answer C wrong because ECS/Redis container/dynamic.
Answer D wrong because Lambda/API dynamic.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html

152.Explain
Answer A wrong because namespace grouping.
Answer B correct because dimension filter metrics app.
Answer C wrong because event triggers.
Answer D wrong because alarm metrics.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html

153.Explain
Answer A wrong because STS temp user pools passwords.
Answer B wrong because IAM no reset.
Answer C wrong because KMS encryption.
Answer D correct because pools sign-up reset.
link ref: https://aws.amazon.com/cognito/

154.Explain
Answer A wrong because CodeCommit repos no envs.
Answer B wrong because CodeBuild builds.
Answer C wrong because Data Pipeline data.
Answer D correct because CodeDeploy groups envs.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-groups.html

155.Explain
Answer A wrong because new table date no cost.
Answer B wrong because increasing units costly spikes.
Answer C correct because random suffix even.
Answer D wrong because GSI queries no writes.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html

156.Explain
Answer A wrong because S3 no in-memory.
Answer B wrong because RDS relational.
Answer C correct because ElastiCache in-memory consistent.
Answer D wrong because Kinesis streaming.
link ref: https://aws.amazon.com/elasticache/

157.Explain
Answer A correct because task port mappings.
Answer B wrong because cluster group.
Answer C wrong because Dockerfile image.
Answer D wrong because CLI management.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

158.Explain
Answer A wrong because KMS keys.
Answer B correct because profiles creds secure.
Answer C wrong because root insecure.
Answer D wrong because CodeCommit code.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

159.Explain
Answer A wrong because RDS queryable no metrics.
Answer B wrong because X-Ray Lambda tracing.
Answer C wrong because Kinesis/DynamoDB complex.
Answer D correct because CloudWatch custom alarms cost.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

160.Explain
Answer A wrong because all once outage.
Answer B wrong because rolling outage.
Answer C wrong because snapshots backup.
Answer D correct because immutable no outage rollback.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

161.Explain
Answer A wrong because S3 cache manual.
Answer B wrong because RDS no origin CloudFront.
Answer C wrong because EC2 local no scalable.
Answer D correct because ElastiCache fronts RDS reads.
link ref: https://aws.amazon.com/elasticache/

162.Explain
Answer A wrong because 3 RCU 3 items strong 2x.
Answer B correct because 3*5KB=15KB strong 2 RCU/4KB=6 RCU.
Answer C wrong because write 70 10*7KB.
Answer D wrong because read 3 write 10 no.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

163.Explain
Answer A wrong because pointer advance no.
Answer B wrong because event source sync.
Answer C correct because unhandled retry.
Answer D wrong because keeping no issue.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html

164.Explain
Answer A wrong because role DB direct insecure.
Answer B correct because Parameter SecureString rotation.
Answer C wrong because S3 metadata no secure.
Answer D wrong because hardcode no rotation.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

165.Explain
Answer A wrong because another function duplicate.
Answer B correct because update-function-code updates.
Answer C wrong because remove no.
Answer D wrong because alias versions.
link ref: https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-code.html

166.Explain
Answer A correct because private subnet VPC.
Answer B wrong because NACL outbound default.
Answer C correct because NAT internet private.
Answer D wrong because public no DB.
Answer E wrong because env no access.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html

167.Explain
Answer A correct because change no master trigger.
Answer B correct because earlier failure stops.
Answer C wrong because CodePipeline no cluster.
Answer D wrong because config correct assumed.
Answer E wrong because permissions ok assumed.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/troubleshooting.html

168.Explain
Answer A wrong because user pool no notifications.
Answer B wrong because SyncCallback no.
Answer C wrong because stream analysis.
Answer D correct because push sync role devices.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/push-sync.html

169.Explain
Answer A wrong because API Gateway S3 static.
Answer B wrong because Lambda Dynamo serverless.
Answer C correct because EC2 Aurora LAMP.
Answer D wrong because Cognito RDS auth DB.
Answer E wrong because ECS EBS container.
link ref: https://aws.amazon.com/ec2/

170.Explain
Answer A correct because long polling empty minimal delay.
Answer B wrong because compress no delay.
Answer C wrong because short more requests.
Answer D wrong because split no.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html

171.Explain
Answer A wrong because images EBS local.
Answer B correct because S3 both shared.
Answer C wrong because S3 images local no shared.
Answer D wrong because local no shared.
link ref: https://aws.amazon.com/s3/

172.Explain
Answer A wrong because SNS sync.
Answer B wrong because SNS async.
Answer C correct because stream sync trigger.
Answer D wrong because async no order.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.html

173.Explain
Answer A correct because PATH CLI.
Answer B wrong because access denied different.
Answer C wrong because creds after.
Answer D wrong because script no.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

174.Explain
Answer A wrong because fleet fixed no auto.
Answer B correct because Auto Scaling queue depth fleet.
Answer C wrong because Kinesis Lambda batch no fraud time.
Answer D wrong because Streams Lambda no long process.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-using-sqs-queue.html

175.Explain
Answer A wrong because LC_ALL locale no env limit.
Answer B wrong because Cognito no env.
Answer C wrong because S3 no env.
Answer D correct because Parameter large env.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

176.Explain
Answer A wrong because InvalidateCache no API.
Answer B wrong because endpoint custom.
Answer C correct because Cache-Control invalidates.
Answer D wrong because query no standard.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html

177.Explain
Answer A wrong because CloudWatch Lambda no S3 events.
Answer B correct because S3 Event Lambda real-time.
Answer C wrong because EC2 cron managed.
Answer D wrong because EMR big data.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-event-types-and-destinations.html

178.Explain
Answer A wrong because Swagger Beanstalk no serverless.
Answer B wrong because CodeDeploy no serverless.
Answer C correct because SAM inline Swagger.
Answer D correct because SAM references Swagger.
Answer E wrong because inline Lambda no API.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html

179.Explain
Answer A wrong because change existing thumbnails upload time.
Answer B wrong because async invoke upload path.
Answer C correct because S3 event separate thumbnail no impact.
Answer D wrong because SQS scheduled complex.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html

180.Explain
Answer A wrong because update function URL change endpoint.
Answer B wrong because phased no Gateway.
Answer C correct because new stage v2 old v1.
Answer D wrong because CloudFront CDN.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html

181.Explain
Answer A correct because Cognito pools custom authorizer JWT.
Answer B wrong because broker complex.
Answer C wrong because DynamoDB STS insecure.
Answer D wrong because RDS creds bad.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html

182.Explain
Answer A wrong because root standard.
Answer B wrong because bin binaries.
Answer C wrong because ebextension sub.
Answer D correct because .ebextensions configs.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html

183.Explain
Answer A wrong because more RAM CPU connection bottleneck.
Answer B wrong because DB size no connections.
Answer C correct because global connection reuse init.
Answer D wrong because DynamoDB no pooling.
link ref: https://docs.aws.amazon.com/lambda/latest/operatorguide/connection-reuse.html

184.Explain
Answer A wrong because region no CORS.
Answer B wrong because same bucket no required.
Answer C wrong because port 80 unrelated.
Answer D correct because CORS cross-bucket.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors.html

185.Explain
Answer A wrong because Events monitor insert.
Answer B correct because S3 event Lambda insert.
Answer C wrong because Lambda poll.
Answer D wrong because cron scheduled.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html

186.Explain
Answer A wrong because snapshot S3 no.
Answer B wrong because Route 53 alias blue green no.
Answer C correct because new deployment last known ID.
Answer D wrong because Pipeline promote no.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-codedeploy-rollback.html

187.Explain
Answer A wrong because role assets code no.
Answer B correct because policy assets code access.
Answer C wrong because policy open all.
Answer D wrong because code Lambda static no.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html

188.Explain
Answer A wrong because trigger Lambda console CodePipeline source.
Answer B correct because event trigger Pipeline console Lambda.
Answer C wrong because alarm status changes Lambda.
Answer D wrong because Events rule CodePipeline source.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/integrations-lambda.html

189.Explain
Answer A wrong because build EC2 package EBS deploy EBS.
Answer B correct because build local package S3 deploy S3.
Answer C wrong because build local deploy S3 package use.
Answer D wrong because build local package Commit deploy Commit.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html

190.Explain
Answer A wrong because IAM user creds EBS insecure long-lived.
Answer B wrong because IAM user creds user data insecure plain text.
Answer C correct because EC2 role read S3 attached secure temporary creds.
Answer D wrong because no S3 service role; roles for services assuming.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

191.Explain
Answer A correct because S3 bucket CodePipeline file change start.
Answer B wrong because EBS encrypted volume file change no.
Answer C correct because CodeCommit repo commit change start.
Answer D wrong because S3 bucket 15min no change.
Answer E wrong because EC2 ephemeral changes start no.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/connections-gitbucket.html

192.Explain
Answer A wrong because SQS EC2 poll no Auto Scaling.
Answer B correct because SQS EC2 ASG poll scalable.
Answer C wrong because support timeout 60 no process.
Answer D wrong because direct RDS insert no scalable.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-using-sqs-queue.html

193.Explain
Answer A wrong because Node.js Python no speed.
Answer B wrong because layer libs no cold start.
Answer C wrong because max CPU memory proportional.
Answer D correct because memory increases CPU speed.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html

194.Explain
Answer A wrong because EC2 dependencies no.
Answer B wrong because RDS migrate no.
Answer C correct because rollback Lambda previous version.
Answer D wrong because different Region no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/versions.html

195.Explain
Answer A correct because DynamoDB external scalable sessions.
Answer B wrong because Cognito auth.
Answer C correct because ElastiCache memory sessions.
Answer D wrong because EBS block no shared.
Answer E wrong because SQS messaging.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html

196.Explain
Answer A wrong because SDK logs CloudWatch no.
Answer B correct because agent on-prem IAM CloudWatch.
Answer C wrong because S3 files CloudWatch read no.
Answer D wrong because EC2 forward logs complex.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/QuickStartEC2Instance.html

197.Explain
Answer A wrong because identity pool temp Cognito Authorizer.
Answer B wrong because database token Lambda authorizer.
Answer C correct because user pool Cognito Authorizer token expire refresh.
Answer D wrong because IAM user invoke policy authorizer.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html

198.Explain
Answer A wrong because Spring DI increases cold start.
Answer B correct because reduce package SDK modules size.
Answer C correct because memory allocation CPU.
Answer D wrong because timeout no cold start.
Answer E wrong because invocation mode no cold start.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

199.Explain
Answer A wrong because VPN logs connection no subnet.
Answer B wrong because BGP logs routing no traffic.
Answer C correct because VPC Flow Logs capture subnet traffic.
Answer D wrong because Trail API no network.
link ref: https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html

200.Explain
Answer A wrong because no s3:EncryptionConfiguration action.
Answer B wrong because bucket policy IAM upload no KMS.
Answer C correct because IAM kms:GenerateDataKey SSE-KMS.
Answer D wrong because ACL upload no KMS.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/iam-policies.html

201.Explain
Answer A correct because Amazon Cognito hosted UI allows customization with logos, CSS, and branding for login pages without building custom interfaces.
Answer B wrong because Cognito doesn't host uploaded login pages; it's for auth flows, not static hosting.
Answer C wrong because API Gateway proxies APIs, not hosts login pages; Cognito integration is for auth, not saving links.
Answer D wrong because Cognito app settings handle client details but don't upload logos for custom pages; hosted UI is for that.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/hosted-ui.html

202.Explain
Answer A wrong because DeleteItem removes items, unnecessary for update/create.
Answer B wrong because UpdateItem assumes existence; DescribeTable is metadata, not data ops.
Answer C wrong because GetRecords is Streams, UpdateTable schema.
Answer D correct because UpdateItem modifies existing or creates if absent (with condition); GetItem retrieves, PutItem creates.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html

203.Explain
Answer A wrong because SSE-S3 uses AWS keys with no user audit trails.
Answer B correct because SSE-KMS provides CloudTrail-audited key usage for who/when.
Answer C wrong because SSE-C uses customer keys without AWS auditing.
Answer D wrong because self-managed keys lack AWS integration/audit.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html

204.Explain
Answer A wrong because doubling max servers increases cost without fixing static latency.
Answer B wrong because Lambda is serverless compute, not for static content hosting.
Answer C wrong because vertical scaling improves instance performance but not global distribution.
Answer D correct because CloudFront caches static content at edges, reducing latency worldwide.
Answer E correct because S3 stores static files durably/scalably; pair with CloudFront for delivery.
link ref: https://aws.amazon.com/cloudfront/

205.Explain
Answer A wrong because presigned URLs expire; saving invalidates over time.
Answer B correct because S3 key in DynamoDB persists; VPC endpoint secures private access post-login.
Answer C wrong because base64 bloats data, inefficient for images.
Answer D wrong because generating presigned on login is per-session overhead.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/vpc-endpoints.html

206.Explain
Answer A wrong because multiple Regions add latency/complexity, no CPU boost.
Answer B wrong because AZs are for HA, not compute.
Answer C wrong because layers reduce size but not CPU.
Answer D correct because Lambda CPU scales with memory; max memory maximizes CPU.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html

207.Explain
Answer A correct because update connection strings to RDS endpoint/port for seamless migration.
Answer B wrong because SDK creds unnecessary; RDS uses IAM DB auth optional.
Answer C wrong because new EC2 role doesn't update existing app connections.
Answer D wrong because Lambda routing adds latency/complexity.
link ref: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html

208.Explain
Answer A correct because target tracking scales ECS on SQS visible messages, handling spikes cost-effectively.
Answer B wrong because Swarm is Docker orchestration, not AWS-native.
Answer C wrong because scheduler manages tasks, not scales on metrics.
Answer D wrong because step scaling is reactive thresholds, less dynamic than target.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-auto-scaling.html

209.Explain
Answer A wrong because IAM is for AWS access, not social/app login.
Answer B wrong because identity pools map identities to creds, not user registration.
Answer C correct because user pools handle sign-up, social federation (Google/Facebook).
Answer D wrong because Directory Service is enterprise AD, not social/mobile.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-social-idp.html

210.Explain
Answer A correct because Lambda authorizer validates headers against DynamoDB for custom auth.
Answer B wrong because models define payloads, no auth; access to table unnecessary.
Answer C wrong because integration requests map, no auth comparison.
Answer D wrong because Cognito authorizer uses pools, not DynamoDB tables.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html

211.Explain
Answer A wrong because GetFederationToken for role assumption, no MFA.
Answer B wrong because GetCallerIdentity gets identity, no MFA temp creds.
Answer C correct because GetSessionToken generates MFA-protected temp creds for API calls.
Answer D wrong because DecodeAuthorizationMessage decodes errors, no MFA.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html

212.Explain
Answer A correct because KMS throttling (e.g., 10k req/s) requires support increase for high reads.
Answer B correct because exponential backoff retries throttled requests without overwhelming.
Answer C wrong because S3 limits separate; error is KMS.
Answer D wrong because CMK size fixed (256-bit); import no larger.
Answer E wrong because multiple CMKs distribute but no solve single-key throttling.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/quotas.html

213.Explain
Answer A wrong because handler/core separation is best practice, not for notifications.
Answer B wrong because CloudWatch Events schedules/triggers, no data send.
Answer C correct because SNS publishes processed data to admins (email/SMS).
Answer D wrong because SQS queues for processing, not direct notify.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-sns.html

214.Explain
Answer A wrong because client-side manual rotation.
Answer B wrong because import custom no auto annual.
Answer C correct because KMS auto-rotates managed keys annually.
Answer D wrong because export KMS no encrypt.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html

215.Explain
Answer A wrong because x-Version header custom routing in Lambda, no Gateway support.
Answer B wrong because authorizer validates, no version routing.
Answer C wrong because resource policy secures, no version isolation.
Answer D correct because stages (dev/prod) unique endpoints; variables pass context.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html

216.Explain
Answer A wrong because Encrypt small payloads.
Answer B wrong because library custom no KMS.
Answer C wrong because encrypted key no decrypt.
Answer D correct because GenerateDataKey plaintext encrypt.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#data-keys

217.Explain
Answer A wrong because CLI disassociate no.
Answer B wrong because AWS CLI no disassociate.
Answer C wrong because policy no disassociate.
Answer D correct because recreate no RDS.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.db.html

218.Explain
Answer A wrong because sticky same instance.
Answer B wrong because SQS no sessions.
Answer C correct because DynamoDB scalable sessions.
Answer D wrong because draining termination.
link ref: https://aws.amazon.com/blogs/aws/elastic-load-balancer-support-for-amazon-dynamodb/

219.Explain
Answer A wrong because Glue ETL no real-time.
Answer B wrong because ElastiCache no updates.
Answer C wrong because Firehose delivery no updates.
Answer D correct because Streams changes real-time.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html

220.Explain
Answer A wrong because Subversion central.
Answer B wrong because CodeBuild builds.
Answer C correct because CodeCommit git distributed.
Answer D wrong because CodeStar projects.
link ref: https://aws.amazon.com/codecommit/

221.Explain
Answer A wrong because EC2 cron managed.
Answer B wrong because env no scheduling.
Answer C correct because Events schedule Lambda.
Answer D wrong because SNS timer no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents.html

222.Explain
Answer A wrong because query no sort score.
Answer B correct because GSI partition sport sort score top.
Answer C wrong because scan inefficient.
Answer D wrong because LSI partition.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

223.Explain
Answer A wrong because bucket policy S3 no KMS.
Answer B correct because IAM role EC2 KMS decrypt.
Answer C wrong because key policy enable instance no.
Answer D wrong because ACL objects.
Answer E wrong because Parameter storage.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/iam-policies.html

224.Explain
Answer A correct because delay hides add.
Answer B wrong because after consume no delay.
Answer C wrong because poll consumer.
Answer D wrong because delete delay no.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-delay-queues.html

225.Explain
Answer A wrong because S3 direct no concurrent.
Answer B wrong because FTP central no AWS.
Answer C correct because CodeCommit direct deploy minimal.
Answer D wrong because EC2 repo bottleneck.
link ref: https://aws.amazon.com/codecommit/

226.Explain
Answer A wrong because EMR big data.
Answer B correct because DAX caches DynamoDB.
Answer C wrong because SQS messaging.
Answer D wrong because CloudFront CDN.
link ref: https://aws.amazon.com/dynamodb/dax/

227.Explain
Answer A wrong because default SSE-S3 no client.
Answer B wrong because Cognito auth no encryption.
Answer C wrong because Lambda processing.
Answer D correct because client-side KMS secure transmit/storage.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingClientSideEncryption.html

228.Explain
Answer A wrong because role AROA assumed.
Answer B wrong because default no.
Answer C correct because ASge access key principal.
Answer D wrong because account service.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html

229.Explain
Answer A correct because pagination large lists.
Answer B wrong because shorthand input.
Answer C wrong because parameters commands.
Answer D wrong because quoting args.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-pagination.html

230.Explain
Answer A wrong because security groups network.
Answer B wrong because ECR images.
Answer C wrong because agent containers.
Answer D correct because task ports.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

231.Explain
Answer A wrong because DynamoDB NoSQL metadata.
Answer B wrong because EC2 no storage.
Answer C wrong because Lambda compute.
Answer D wrong because RDS relational slow indexing.
link ref: https://aws.amazon.com/dynamodb/

232.Explain
Answer A wrong because VPC Flow network.
Answer B correct because CloudWatch app logs.
Answer C wrong because CloudSearch search.
Answer D wrong because Trail API.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html

233.Explain
Answer A wrong because KPL producers.
Answer B wrong because reduce retention less.
Answer C correct because UpdateShardCount capacity.
Answer D wrong because PutRecords batches puts shards needed.
link ref: https://docs.aws.amazon.com/streams/latest/dev/developing-producers-with-kpl.html

234.Explain
Answer A correct because nested reusable.
Answer B wrong because credentials insecure.
Answer C wrong because remove mappings flexibility.
Answer D wrong because Include snippets public risky.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/best-practices.html

235.Explain
Answer A correct because backoffs rate.
Answer B wrong because load balance no API.
Answer C wrong because EC2 no.
Answer D wrong because delay worse.
link ref: https://docs.aws.amazon.com/general/latest/gr/api-retries.html

236.Explain
Answer A wrong because script cron managed.
Answer B correct because TTL auto-deletes.
Answer C wrong because new table daily costly.
Answer D wrong because ItemExpiration no; TTL.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-how-to.html

237.Explain
Answer A wrong because split smaller serial.
Answer B wrong because sync one slow.
Answer C correct because async event parallel.
Answer D wrong because join first serial.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html

238.Explain
Answer A correct because multi-part large.
Answer B wrong because Direct Connect network no size.
Answer C wrong because no support size.
Answer D wrong because region no.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html

239.Explain
Answer A wrong because docker pull direct no auth.
Answer B correct because get-login docker login pull.
Answer C wrong because get-login output run.
Answer D wrong because get-download layers no pull.
link ref: https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html

240.Explain
Answer A wrong because user pools email sign-up.
Answer B wrong because Mobile Hub deprecated.
Answer C wrong because Sync data.
Answer D wrong because cloud logic backend.
link ref: https://aws.amazon.com/cognito/

241.Explain
Answer A wrong because no www.
Answer B correct because s3-website-region.
Answer C wrong because no endpoint.
Answer D wrong because no tokyo.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteEndpoints.html

242.Explain
Answer A wrong because single table accumulates.
Answer B wrong because individual delete costly.
Answer C correct because delete/create per hour minimal.
Answer D wrong because create no delete accumulates.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.DeleteTable.html

243.Explain
Answer A wrong because memory no shared.
Answer B wrong because storage no.
Answer C wrong because EBS no shared.
Answer D correct because ElastiCache shared.
Answer E wrong because Glacier no.
link ref: https://aws.amazon.com/elasticache/

244.Explain
Answer A wrong because EBS no serving.
Answer B correct because signed URLs control.
Answer C wrong because CloudFront signed too.
Answer D wrong because SG EC2 no S3.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html

245.Explain
Answer A wrong because pessimistic no.
Answer B correct because optimistic control.
Answer C correct because conditional writes.
Answer D wrong because no restrict reads.
Answer E wrong because no restrict writes.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate

246.Explain
Answer A wrong because bulk no devices.
Answer B wrong because push handles SNS register.
Answer C wrong because vending custom.
Answer D correct because CreatePlatformEndpoint tokens.
link ref: https://docs.aws.amazon.com/sns/latest/dg/sns-mobile-application-as-subscriber.html

247.Explain
Answer A wrong because no storage instances.
Answer B wrong because range secondary.
Answer C correct because hot hash throttling.
Answer D wrong because sort no capacity.
Answer E wrong because no auto scaling then.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html

248.Explain
Answer A wrong because sequential hotspots.
Answer B correct because instanceID distributes.
Answer C wrong because year less.
Answer D wrong because hour hotspots.
Answer E wrong because year hotspots.
link ref: https://aws.amazon.com/premiumsupport/knowledge-center/s3-request-limit-avoid/

249.Explain
Answer A wrong because not exactly once/FIFO.
Answer B wrong because not exactly once.
Answer C wrong because FIFO order.
Answer D correct because at-least-once no order.
link ref: https://aws.amazon.com/sqs/features/

250.Explain
Answer A wrong because IAM no LDAP.
Answer B correct because LDAP STS assume.
Answer C wrong because STS no LDAP.
Answer D correct because broker LDAP STS federated.
Answer E wrong because broker STS assume.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html

251.Explain
Answer A correct because upload welcome.html.
Answer B wrong because no subfolder.
Answer C correct because set index welcome.html.
Answer D wrong because move index no.
Answer E wrong because error errors.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/IndexDocumentSupport.html

252.Explain
Answer A wrong because Triple DES no S3.
Answer B correct because AES-256 SSE.
Answer C wrong because Blowfish no.
Answer D wrong because RC5 no.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html

253.Explain
Answer A correct because annotations custom indexed.
Answer B wrong because metadata no indexed.
Answer C wrong because env config.
Answer D wrong because plugins SDK.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-annotations

254.Explain
Answer A wrong because no direct select deployment.
Answer B correct because new env ALB swap CNAME.
Answer C correct because clone change type swap.
Answer D wrong because edit no change LB.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.elb.html

255.Explain
Answer A wrong because CodePipeline CI/CD.
Answer B wrong because S3 storage.
Answer C wrong because CodeBuild builds.
Answer D correct because CodeCommit git repo.
link ref: https://aws.amazon.com/codecommit/

256.Explain
Answer A wrong because CodePipeline orchestrates.
Answer B wrong because CodeBuild compiles.
Answer C wrong because Beanstalk PaaS.
Answer D correct because CodeDeploy EC2/on-prem.
link ref: https://aws.amazon.com/codedeploy/

257.Explain
Answer A wrong because DLQ async.
Answer B wrong because Gateway source.
Answer C wrong because error no prevent.
Answer D correct because support account limit.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-limits.html

258.Explain
Answer A wrong because RDS app slow.
Answer B wrong because shared file complex.
Answer C correct because Memcached low latency.
Answer D wrong because DynamoDB higher.
link ref: https://aws.amazon.com/elasticache/memcached/

259.Explain
Answer A wrong because GSI separate provision under.
Answer B wrong because read primary ok.
Answer C wrong because streams changes.
Answer D wrong because other table separate.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

260.Explain
Answer A wrong because concurrent no prevent.
Answer B correct because conditional prevent overwrite.
Answer C wrong because atomic per.
Answer D wrong because batch no condition.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate

261.Explain
Answer A wrong because view type content.
Answer B correct because event source triggers.
Answer C wrong because SNS no.
Answer D wrong because timeout no trigger.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html

262.Explain
Answer A wrong because 30s infrequent.
Answer B correct because high-res 5s 15s average.
Answer C wrong because standard 1min.
Answer D wrong because standard infrequent.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

263.Explain
Answer A wrong because SQS/EC2 no real-time.
Answer B wrong because S3/Redshift batch.
Answer C wrong because Pipeline scheduled.
Answer D correct because Kinesis Streams real-time.
link ref: https://aws.amazon.com/kinesis/data-streams/

264.Explain
Answer A correct because specific Create/DeleteBranch.
Answer B wrong because Put* broad.
Answer C wrong because Update* no branches.
Answer D wrong because * all.
link ref: https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-permissions-reference.html

265.Explain
Answer A wrong because ACM certs.
Answer B correct because Parameter Store secure.
Answer C wrong because Advisor recommendations.
Answer D correct because KMS encrypts.
Answer E wrong because GuardDuty security.
link ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store.html

266.Explain
Answer A wrong because dockerrun ECS.
Answer B wrong because buildspec CodeBuild.
Answer C correct because appspec hooks.
Answer D wrong because ebextensions config.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file.html

267.Explain
Answer A wrong because Encrypt no large.
Answer B wrong because GenerateRandom no KMS.
Answer C wrong because encrypted no decrypt.
Answer D correct because plaintext data key KMS.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#data-keys

268.Explain
Answer A wrong because CacheHit caching.
Answer B correct because IntegrationLatency backend.
Answer C wrong because CacheMiss caching.
Answer D correct because Latency total.
Answer E wrong because Count requests.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-metrics-and-dimensions.html

269.Explain
Answer A correct because CloudFront signed cheap.
Answer B wrong because per customer costly.
Answer C wrong because Lambda@Edge custom.
Answer D wrong because API/Lambda overhead.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-signed-urls.html

270.Explain
Answer A correct because backoff throttling.
Answer B wrong because SQS bus layer.
Answer C wrong because Gateway throttles more.
Answer D wrong because Firehose streams.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html

271.Explain
Answer A wrong because immutable full.
Answer B wrong because rolling capacity.
Answer C wrong because all once down.
Answer D correct because rolling batch capacity min cost.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

272.Explain
Answer A wrong because single no independent.
Answer B correct because separate independent.
Answer C wrong because multiple HTTP one background.
Answer D wrong because multiple background one HTTP.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.environments.html

273.Explain
Answer A correct because changesets preview.
Answer B wrong because policies prevent.
Answer C wrong because Metadata info.
Answer D wrong because Resources define.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html

274.Explain
Answer A wrong because functions management.
Answer B wrong because stages versions aliases no endpoint.
Answer C correct because aliases versions no API.
Answer D wrong because tags no routing.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html

275.Explain
Answer A wrong because certs incoming.
Answer B wrong because allows need deny.
Answer C wrong because HTTPS redirect incoming.
Answer D correct because deny non-secure HTTPS.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html

276.Explain
Answer A wrong because SQS/SNS messaging.
Answer B correct because ELB EC2 REST.
Answer C wrong because ElastiCache/Elasticsearch storage/search.
Answer D correct because Gateway Lambda serverless REST.
Answer E wrong because S3/CloudFront static.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html

277.Explain
Answer A correct because /tmp local temp.
Answer B wrong because EFS persistent slow.
Answer C wrong because EBS block.
Answer D wrong because S3 latency.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html

278.Explain
Answer A wrong because EC2 NoSQL self.
Answer B correct because ElastiCache cache-aside profiles.
Answer C wrong because RDS write-through relational.
Answer D wrong because write-through populates cache-aside reads.
link ref: https://aws.amazon.com/elasticache/

279.Explain
Answer A wrong because VM Import self.
Answer B wrong because Lightsail simple no dynamic.
Answer C correct because Beanstalk manages.
Answer D wrong because S3/CloudFront static.
link ref: https://aws.amazon.com/elasticbeanstalk/

280.Explain
Answer A correct because context request ID.
Answer B wrong because event no ID file less.
Answer C wrong because event ID console standard.
Answer D wrong because context ID file less.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/nodejs-logging.html

281.Explain
Answer A correct because EC2 assume AccessPII.
Answer B wrong because direct no.
Answer C wrong because AWS API temp.
Answer D correct because AssumeRole temp.
Answer E wrong because GetSessionToken users.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

282.Explain
Answer A wrong because event source no trace API.
Answer B wrong because ALB no DynamoDB.
Answer C wrong because limit no timing.
Answer D correct because X-Ray traces.
link ref: https://aws.amazon.com/xray/

283.Explain
Answer A wrong because Multi-AZ HA.
Answer B correct because replica offload reads.
Answer C wrong because ElastiCache buffers writes reads issue.
Answer D wrong because DynamoDB overkill.
link ref: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html

284.Explain
Answer A wrong because BatchWriteItem no transactional.
Answer B correct because TransactWriteItems all-nothing.
Answer C wrong because SQS messaging.
Answer D wrong because Aurora sync complex.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html

285.Explain
Answer A wrong because S3 Lambda indirect.
Answer B wrong because Kinesis Lambda overkill.
Answer C wrong because API role no creds.
Answer D correct because PutMetricData IAM EC2.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

286.Explain
Answer A wrong because CLI no large.
Answer B correct because Extended Library S3 >256KB.
Answer C wrong because EBS block.
Answer D wrong because EFS file CLI no.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-s3-messages.html

287.Explain
Answer A wrong because X-Ray no metrics graph.
Answer B correct because custom PutMetricData graph.
Answer C wrong because S3 Kinesis complex.
Answer D wrong because DynamoDB CloudFront mismatch.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

288.Explain
Answer A correct because package modules reduce cold.
Answer B wrong because DynamoDB RDS bottleneck.
Answer C correct because connection outside reuse.
Answer D wrong because custom unnecessary.
Answer E wrong because local no connection.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html

289.Explain
Answer A wrong because SES email metric SNS.
Answer B wrong because API-error built-in custom SNS.
Answer C wrong because SES no alert.
Answer D correct because custom CloudWatch SNS.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html

290.Explain
Answer A wrong because multiple complex.
Answer B correct because approval pauses.
Answer C wrong because disable manual.
Answer D wrong because disable no workflow.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/approvals.html

291.Explain
Answer A correct because Redis Cluster HA.
Answer B wrong because EC2 self uptime.
Answer C wrong because Memcached no persistence.
Answer D wrong because Redshift analytics.
link ref: https://aws.amazon.com/elasticache/redis/

292.Explain
Answer A wrong because memory no time.
Answer B wrong because same bucket possible.
Answer C correct because timeout 15min 500s >3s.
Answer D wrong because Java fine.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html

293.Explain
Answer A wrong because SSL transit.
Answer B wrong because KCL no encrypt.
Answer C wrong because Lambda after rest.
Answer D correct because server-side Kinesis rest.
link ref: https://docs.aws.amazon.com/streams/latest/dev/server-side-encryption.html

294.Explain
Answer A wrong because Lambda compute.
Answer B correct because Cognito SAML mobile.
Answer C wrong because IAM internal.
Answer D wrong because EC2 server.
link ref: https://aws.amazon.com/cognito/

295.Explain
Answer A wrong because SNS notification.
Answer B wrong because NetworkIn bytes.
Answer C wrong because CloudFront CDN.
Answer D correct because custom users scaling.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-target-tracking.html

296.Explain
Answer A wrong because API manual.
Answer B wrong because standard CloudFormation Lambda.
Answer C correct because SAM simplifies serverless.
Answer D wrong because bash no automated.
link ref: https://aws.amazon.com/serverless/sam/

297.Explain
Answer A wrong because encryption no restrict.
Answer B correct because item-level key conditions.
Answer C wrong because SQS complexity.
Answer D wrong because client discard inefficient.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/specifying-conditions.html

298.Explain
Answer A wrong because STS temp no guest.
Answer B wrong because Directory AD.
Answer C correct because Cognito unauth guest.
Answer D wrong because SAML federated.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html

299.Explain
Answer A wrong because no compile.
Answer B correct because package S3 modifies.
Answer C wrong because zip template no.
Answer D wrong because no command.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-cli-package.html

300.Explain
Answer A wrong because unzip no.
Answer B wrong because compression no unzip.
Answer C correct because smaller functions size.
Answer D wrong because double no.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html

301.Explain
Answer A wrong because createDeployment redeploys the API but does not associate new keys with usage plans; redeployment propagates changes to stages, but new keys need plan linking for validation.
Answer B wrong because updateAuthorizer updates auth logic, but API key validation is native, not authorizer-based; issue is key-plan association, not authorizer.
Answer C wrong because importApiKeys imports from CSV, not for newly created keys; doesn't link to plans.
Answer D correct because createUsagePlanKey associates the API key with a usage plan, granting access to APIs under that plan after creation.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html

302.Explain
Answer A correct because web identity federation in Cognito allows login with Amazon, Facebook, Google, providing temp creds for S3 access.
Answer B wrong because SAML is enterprise federation (e.g., AD), not social providers like Facebook/Google.
Answer C wrong because IAM keys in code are insecure, hard-coded, and not for mobile user auth.
Answer D wrong because STS AssumeRole requires role assumption, not direct social login integration.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html

303.Explain
Answer A wrong because GetMetricData retrieves metrics, not logs; logs need agent for collection.
Answer B wrong because CloudTrail audits API calls, not app logs from EC2.
Answer C wrong because CloudWatch Events triggers actions, not collects logs; app installation unrelated.
Answer D correct because CloudWatch Logs agent on EC2 pushes instance logs to CloudWatch for monitoring.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/QuickStartEC2Instance.html

304.Explain
Answer A wrong because DeleteItem with condition scans/deletes individually, costly for millions.
Answer B wrong because BatchWriteItem deletes in batches (up to 25), still provision-heavy for millions.
Answer C wrong because recursive scan/DeleteItem inefficient, consumes throughput.
Answer D correct because deleting/recreating table clears data cost-effectively; no provisioned throughput during idle.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.DeleteTable.html

305.Explain
Answer A wrong because bucket name correct; duplicates from retries, not name.
Answer B correct because Lambda retries failed invocations (e.g., errors/timeouts) with delay, causing duplicate processing if not idempotent.
Answer C wrong because S3 outage would cause failures, not duplicates; logs indicate success with duplicates.
Answer D wrong because app resume might cause reprocessing, but logs show request ID duplicates from retries.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-retries.html

306.Explain
Answer A wrong because Lambda serverless compute, not interface management.
Answer B wrong because X-Ray traces performance, not manages services.
Answer C wrong because SQS queues messages, not provides REST interface.
Answer D correct because API Gateway centralizes microservices exposure, simplifying consumer access/scaling.
link ref: https://aws.amazon.com/api-gateway/

307.Explain
Answer A correct because S3 hosts static files (HTML/JS/images/videos), CloudFront distributes globally with caching.
Answer B wrong because EC2/ElastiCache for dynamic, but site is static.
Answer C wrong because ECS/Redis containerized caching, overkill for static.
Answer D wrong because Lambda/API for dynamic APIs, not static content.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html

308.Explain
Answer A correct because custom namespace groups metrics by app, allowing dashboard view of unique metrics per app.
Answer B wrong because dimensions filter within metrics, not create unique names.
Answer C wrong because events trigger actions, not represent metrics.
Answer D wrong because alarms act on metrics, not create them.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html

309.Explain
Answer A wrong because identity pools map to creds, but no self-reset.
Answer B wrong because IAM pools no password reset.
Answer C wrong because KMS encrypts, no users.
Answer D correct because user pools manage sign-up/reset, identity pools creds.
link ref: https://aws.amazon.com/cognito/

310.Explain
Answer A wrong because multiple repos no sequential deploy.
Answer B wrong because CodeBuild multiple builds no env deploy.
Answer C wrong because Data Pipeline data processing no code deploy.
Answer D correct because CodeDeploy groups for Dev/QA/Prod sequential.
link ref: https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-groups.html

311.Explain
Answer A wrong because per-date tables increase management/cost.
Answer B wrong because increasing capacity costly during spikes.
Answer C correct because random suffix distributes writes evenly across partitions.
Answer D wrong because GSI for reads, not write throttling.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html

312.Explain
Answer A wrong because S3 durable but higher latency for in-memory needs.
Answer B wrong because RDS relational, not optimized for inconsistent results tolerance.
Answer C correct because ElastiCache in-memory, scalable for game results with auto-scaling.
Answer D wrong because Kinesis streaming, not storage for results.
link ref: https://aws.amazon.com/elasticache/

313.Explain
Answer A correct because ECS task definition defines containers/ports/volumes for multi-container.
Answer B wrong because ECS cluster is infrastructure, not config.
Answer C wrong because Dockerfile builds images, not environment config.
Answer D wrong because CLI deploys, not configures.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

314.Explain
Answer A wrong because KMS encrypts, not provides access.
Answer B correct because instance profiles auto-provide rotating creds with policies.
Answer C wrong because root user insecure.
Answer D wrong because CodeCommit code storage, not creds.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

315.Explain
Answer A wrong because alarm on CPUUtilization to SNS.
Answer B wrong because CloudTrail no CPU metrics.
Answer C wrong because cron on instance manual.
Answer D wrong because Lambda on CloudTrail mismatch.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html

316.Explain
Answer A wrong because all at once outage.
Answer B wrong because rolling outage.
Answer C wrong because snapshots backup.
Answer D correct because immutable no outage quick rollback.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html

317.Explain
Answer A wrong because S3 cache manual.
Answer B wrong because RDS no origin for CloudFront.
Answer C wrong because EC2 local no scalable.
Answer D correct because ElastiCache fronts RDS for reads.
link ref: https://aws.amazon.com/elasticache/

318.Explain
Answer A wrong because 3 RCU for 3 items, but strong consistent 2x.
Answer B correct because 3 items * 5KB = 15KB, strong read 2 RCU per 4KB, so 6 RCU.
Answer C wrong because write 70 for 10 items * 7KB.
Answer D wrong because read 3, write 10 incorrect.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

319.Explain
Answer A wrong because pointer advance needed.
Answer B wrong because event source sync.
Answer C correct because unhandled error causes retry.
Answer D wrong because keeping up not issue.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html

320.Explain
Answer A wrong because role for DB access direct insecure.
Answer B correct because Parameter Store SecureString with rotation.
Answer C wrong because S3 metadata not secure.
Answer D wrong because hardcode no rotation.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

321.Explain
Answer A wrong because another function duplicate.
Answer B correct because update-function-code updates code.
Answer C wrong because remove not needed.
Answer D wrong because alias for versions.
link ref: https://docs.aws.amazon.com/cli/latest/reference/lambda/update-function-code.html

322.Explain
Answer A correct because private subnet for VPC access.
Answer B wrong because NACL outbound default.
Answer C correct because NAT for internet from private.
Answer D wrong because public subnet no DB access.
Answer E wrong because env var not for access.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html

323.Explain
Answer A wrong because update stack properties to new S3 version.
Answer B correct because update stack to new S3 version.
Answer C wrong because base64 not for code.
Answer D wrong because role for access, but update needed.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html

324.Explain
Answer A correct because Docker image with daemon.
Answer B correct because instrument code.
Answer C wrong because daemon not on EC2 for ECS.
Answer D wrong because instance role for EC2, not tasks.
Answer E wrong because register app not needed.
Answer F correct because task role for permissions.
link ref: https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-docker.html

325.Explain
Answer A wrong because acl condition not for encryption.
Answer B wrong because RDS not for S3.
Answer C wrong because SecureTransport for transit.
Answer D correct because default SSE-S3 encrypts at rest.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/default-bucket-encryption.html

326.Explain
Answer A wrong because Parameters inputs.
Answer B wrong because Outputs results.
Answer C correct because Mappings for region-specific AMIs.
Answer D wrong because Resources define.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/mappings-section-structure.html

327.Explain
Answer A wrong because scan consumes more.
Answer B wrong because strong consistent more RCU.
Answer C correct because query eventual minimal RCU.
Answer D wrong because scan strong more.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html

328.Explain
Answer A wrong because remove origin resets.
Answer B wrong because forwarding not for cache.
Answer C correct because invalidate forces refresh.
Answer D wrong because disable propagates old.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html

329.Explain
Answer A correct because inline code in template.
Answer B correct because S3 zip reference in template.
Answer C wrong because zip to CloudFormation not standard.
Answer D wrong because Git private not direct.
Answer E wrong because S3 bucket for large numbers of environment variables not.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html

330.Explain
Answer A wrong because zip local not for libs.
Answer B wrong because blueprint templates.
Answer C wrong because runtime fixed.
Answer D wrong because zip with all libs.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

331.Explain
Answer A wrong because pass-through no encryption.
Answer B correct because certificates on ELB offload CPU.
Answer C wrong because LSS not exist.
Answer D wrong because install on EC2 increases CPU.
Answer E correct because termination on ELB offloads.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-create-https-ssl-load-balancer.html

332.Explain
Answer A wrong because runtime script increases time.
Answer B correct because zip with all libs.
Answer C wrong because S3 env var for path, but not standard.
Answer D wrong because buildspec for CodeBuild.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html

333.Explain
Answer A wrong because sticky for same instance.
Answer B wrong because SQS no sessions.
Answer C correct because DynamoDB scalable for sessions.
Answer D wrong because draining for termination.
link ref: https://aws.amazon.com/blogs/aws/elastic-load-balancer-support-for-amazon-dynamodb/

334.Explain
Answer A wrong because Glue ETL not real-time.
Answer B wrong because ElastiCache not for updates.
Answer C wrong because Firehose delivery, not updates.
Answer D correct because Streams capture changes near-real time.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html

335.Explain
Answer A wrong because Subversion centralized.
Answer B wrong because CodeBuild builds.
Answer C correct because CodeCommit distributed git.
Answer D wrong because CodeStar projects.
link ref: https://aws.amazon.com/codecommit/

336.Explain
Answer A wrong because EC2 cron managed.
Answer B wrong because env var not for scheduling.
Answer C correct because CloudWatch Events schedule Lambda.
Answer D wrong because SNS timer not standard.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents.html

337.Explain
Answer A wrong because query not sort by score.
Answer B correct because GSI with sport_name partition, score sort for top.
Answer C wrong because scan inefficient.
Answer D wrong because LSI per partition.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html

338.Explain
Answer A wrong because provider for auth.
Answer B wrong because Lambda user creation complex.
Answer C wrong because KMS encryption.
Answer D correct because Cognito unauth roles for limited access.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html

339.Explain
Answer A wrong because bucket policy for S3, but KMS for decrypt.
Answer B correct because IAM role on EC2 needs KMS decrypt permission.
Answer C wrong because key policy enables, but instance needs access.
Answer D wrong because ACL for objects.
Answer E wrong because Parameter for storage.
link ref: https://docs.aws.amazon.com/kms/latest/developerguide/iam-policies.html

340.Explain
Answer A correct because delay hides on add.
Answer B wrong because after consume not delay.
Answer C wrong because poll time consumer side.
Answer D wrong because delete delay not exist.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-delay-queues.html

341.Explain
Answer A wrong because S3 direct no concurrent.
Answer B wrong because FTP central no AWS.
Answer C correct because CodeCommit direct deploy minimal.
Answer D wrong because EC2 repo central bottleneck.
link ref: https://aws.amazon.com/codecommit/

342.Explain
Answer A wrong because EMR big data.
Answer B correct because DAX caches DynamoDB reads.
Answer C wrong because SQS messaging.
Answer D wrong because CloudFront CDN.
link ref: https://aws.amazon.com/dynamodb/dax/

343.Explain
Answer A wrong because default SSE-S3 no client-side.
Answer B wrong because Cognito auth no encryption.
Answer C wrong because Lambda processing.
Answer D correct because client-side KMS secure transmission/storage.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingClientSideEncryption.html

344.Explain
Answer A wrong because role AROA assumed role.
Answer B wrong because default role not used.
Answer C correct because ASge access key principal.
Answer D wrong because account owns service.
link ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html

345.Explain
Answer A correct because pagination large lists.
Answer B wrong because shorthand syntax input.
Answer C wrong because parameters commands.
Answer D wrong because quoting args.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-pagination.html

346.Explain
Answer A wrong because security groups network.
Answer B wrong because ECR images.
Answer C wrong because agent runs containers.
Answer D correct because task definition ports.
link ref: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html

347.Explain
Answer A correct because DynamoDB NoSQL metadata indexing.
Answer B wrong because EC2 storage no.
Answer C wrong because Lambda compute.
Answer D wrong because RDS relational slower indexing.
link ref: https://aws.amazon.com/dynamodb/

348.Explain
Answer A wrong because VPC Flow network.
Answer B correct because CloudWatch Logs app logs.
Answer C wrong because CloudSearch search.
Answer D wrong because CloudTrail API.
link ref: https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html

349.Explain
Answer A wrong because KPL producers.
Answer B wrong because reduce retention less data.
Answer C correct because UpdateShardCount capacity.
Answer D wrong because PutRecords batches puts, but for high throughput shards needed.
link ref: https://docs.aws.amazon.com/streams/latest/dev/developing-producers-with-kpl.html

350.Explain
Answer A correct because nested reusable patterns.
Answer B wrong because credentials insecure.
Answer C wrong because remove mappings flexibility.
Answer D wrong because Include snippets, but public risky.
link ref: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/best-practices.html

351.Explain
Answer A correct because backoffs rate limits.
Answer B wrong because load balance no API.
Answer C wrong because EC2 no help.
Answer D wrong because delay worsens.
link ref: https://docs.aws.amazon.com/general/latest/gr/api-retries.html

352.Explain
Answer A wrong because script cron managed.
Answer B correct because TTL auto-deletes old items.
Answer C wrong because new table daily costly.
Answer D wrong because ItemExpiration not standard; use TTL.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-how-to.html

353.Explain
Answer A wrong because split smaller still serial.
Answer B wrong because sync one by one slow.
Answer C correct because async event parallel.
Answer D wrong because join first serial.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html

354.Explain
Answer A correct because multi-part for large objects.
Answer B wrong because Direct Connect network, not size.
Answer C wrong because no support for size.
Answer D wrong because region no issue.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html

355.Explain
Answer A wrong because docker pull direct no auth.
Answer B correct because get-login for docker login, then pull.
Answer C wrong because get-login output to run.
Answer D wrong because get-download for layers, not pull.
link ref: https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html

356.Explain
Answer A correct because user pools for email sign-up.
Answer B wrong because Mobile Hub deprecated.
Answer C wrong because Sync for data.
Answer D wrong because cloud logic for backend.
link ref: https://aws.amazon.com/cognito/

357.Explain
Answer A wrong because user creds in code insecure.
Answer B correct because execution role for Lambda secure.
Answer C wrong because bucket policy principal for S3, but Lambda needs role.
Answer D wrong because managed policy too broad.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html

358.Explain
Answer A wrong because KMS for encryption.
Answer B correct because Origin Protocol HTTPS only.
Answer C wrong because port 443 for origin.
Answer D correct because Viewer Policy HTTPS or redirect.
Answer E wrong because Restrict Viewer for signed URLs.
link ref: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html

359.Explain
Answer A wrong because 50 for eventual.
Answer B wrong because 100 for eventual 100 items.
Answer C correct because strong 2x RCU, 100 items * 5KB /4KB *2 =200.
Answer D wrong because 500 too much.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html

360.Explain
Answer A wrong because S3 logs are access logs.
Answer B wrong because CloudTrail is API calls.
Answer C correct because CloudWatch collects Lambda logs.
Answer D wrong because DynamoDB no logs.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html

361.Explain
Answer A wrong because EBS persistent.
Answer B wrong because EFS shared.
Answer C correct because /tmp for temp, auto-cleaned.
Answer D wrong because S3 persistent.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html

362.Explain
Answer A wrong because CloudFormation templates.
Answer B correct because Beanstalk manages Tomcat.
Answer C wrong because S3 static.
Answer D wrong because CodePipeline CI/CD.
link ref: https://aws.amazon.com/elasticbeanstalk/

363.Explain
Answer A correct because ElastiCache for sessions scalable.
Answer B wrong because EBS not shared.
Answer C wrong because Instance Store not persistent.
Answer D wrong because root not shared.
link ref: https://aws.amazon.com/elasticache/

364.Explain
Answer A correct because SQS for async message passing.
Answer B wrong because Cognito auth.
Answer C wrong because Kinesis streaming.
Answer D correct because SNS for pub/sub.
Answer E wrong because ElastiCache caching.
link ref: https://aws.amazon.com/sqs/

365.Explain
Answer A correct because delete root keys secure.
Answer B wrong because unused keys risk.
Answer C wrong because embed insecure.
Answer D correct because roles least privilege.
Answer E wrong because same key consistency bad.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html

366.Explain
Answer A wrong because signature for CLI.
Answer B wrong because configure stores keys, insecure.
Answer C correct because role on instance provides creds.
Answer D wrong because params expose keys.
link ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html

367.Explain
Answer A wrong because remove ALB loses benefits.
Answer B wrong because Classic LB no X-Forwarded-For list.
Answer C correct because app inspects X-Forwarded-For for real IP.
Answer D wrong because custom header requires client change.
link ref: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/x-forwarded-headers.html

368.Explain
Answer A wrong because CLI disassociate not exist.
Answer B wrong because AWS CLI no disassociate.
Answer C wrong because policy not for disassociate.
Answer D correct because recreate without RDS.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.managing.db.html

369.Explain
Answer A correct because change not in master no trigger.
Answer B correct because earlier failure stops pipeline.
Answer C wrong because CodePipeline not cluster.
Answer D wrong because config correct assumed.
Answer E wrong because permissions ok assumed.
link ref: https://docs.aws.amazon.com/codepipeline/latest/userguide/troubleshooting.html

370.Explain
Answer A wrong because user pool no notifications.
Answer B wrong because SyncCallback not exist.
Answer C wrong because stream for analysis.
Answer D correct because push sync with role notifies devices.
link ref: https://docs.aws.amazon.com/cognito/latest/developerguide/push-sync.html

371.Explain
Answer A wrong because API Gateway S3 static.
Answer B wrong because Lambda Dynamo serverless.
Answer C correct because EC2 with Aurora for LAMP.
Answer D wrong because Cognito RDS auth + DB.
Answer E wrong because ECS EBS container.
link ref: https://aws.amazon.com/ec2/

372.Explain
Answer A correct because long polling reduces empty responses, minimal delay.
Answer B wrong because compress not delay.
Answer C wrong because short polling more requests.
Answer D wrong because split payload not help.
link ref: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html

373.Explain
Answer A wrong because images to EBS local.
Answer B correct because S3 for both, shared.
Answer C wrong because S3 images, local disks not shared.
Answer D wrong because local images not shared.
link ref: https://aws.amazon.com/s3/

374.Explain
Answer A wrong because SNS sync.
Answer B wrong because SNS async.
Answer C correct because stream sync trigger.
Answer D wrong because async not guarantee order.
link ref: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.html

375.Explain
Answer A correct because PATH needed for CLI.
Answer B wrong because access denied different error.
Answer C wrong because creds after configure.
Answer D wrong because script mode unrelated.
link ref: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

376.Explain
Answer A wrong because fleet fixed, not auto-scale.
Answer B correct because Auto Scaling with queue depth scales fleet.
Answer C wrong because Kinesis with Lambda batch, but not for fraud time.
Answer D wrong because DynamoDB Streams with Lambda, but not for long process.
link ref: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-using-sqs-queue.html

377.Explain
Answer A wrong because LC_ALL locale, not env limit.
Answer B wrong because Cognito not for env vars.
Answer C wrong because S3 not for env vars.
Answer D correct because Parameter Store stores large env vars.
link ref: https://aws.amazon.com/systems-manager/parameter-store/

378.Explain
Answer A wrong because InvalidateCache not API.
Answer B wrong because endpoint custom.
Answer C correct because Cache-Control header invalidates.
Answer D wrong because query param not standard.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html

379.Explain
Answer A wrong because CloudWatch Lambda not for S3 events.
Answer B correct because S3 Event to Lambda real-time.
Answer C wrong because EC2 cron managed.
Answer D wrong because EMR big data.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-event-types-and-destinations.html

380.Explain
Answer A wrong because Swagger Beanstalk not serverless.
Answer B wrong because CodeDeploy not serverless.
Answer C correct because SAM inline Swagger.
Answer D correct because SAM references Swagger file.
Answer E wrong because inline in Lambda not API.
link ref: https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html

381.Explain
Answer A wrong because change existing thumbnails upload time.
Answer B wrong because async invoke upload path.
Answer C correct because S3 event separate thumbnail no impact.
Answer D wrong because SQS scheduled complex.
link ref: https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html

382.Explain
Answer A wrong because update function URL change endpoint.
Answer B wrong because phased not in API Gateway.
Answer C correct because new stage v2 keeps old clients on v1.
Answer D wrong because CloudFront for CDN.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html

383.Explain
Answer A correct because Cognito user pools with custom authorizer for JWT.
Answer B wrong because custom broker complex.
Answer C wrong because DynamoDB with STS insecure.
Answer D wrong because RDS for creds bad practice.
link ref: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html

384.Explain
Answer A wrong because root standard.
Answer B wrong because bin binaries.
Answer C wrong because ebextension subfolder.
Answer D correct because .ebextensions for configs.
link ref: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html

385.Explain
Answer A wrong because more RAM increases CPU but connection is bottleneck.
Answer B wrong because DB size not connections.
Answer C correct because global connection reuse reduces init time.
Answer D wrong because DynamoDB no pooling needed.
link ref: https://docs.aws.amazon.com/lambda/latest/operatorguide/connection-reuse.html

386.Explain
Answer A wrong because region not CORS.
Answer B wrong because same bucket not required.
Answer C wrong because port 80 security unrelated.
Answer D correct because CORS enables cross-bucket access.
link ref: https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors.html

387.Explain
Answer A wrong because user id prefixes not optimal for PUTs.
Answer B wrong because timestamps sequential hotspots.
Answer C wrong because file hashes for files, but folders for prefixes.
Answer D correct because hex hashes on folders distribute PUT requests.
link ref: https://aws.amazon.com/premiumsupport/knowledge-center/s3-request-limit-avoid/