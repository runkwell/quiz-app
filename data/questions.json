[
  {
    "id": 1,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 2,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 3,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 4,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 5,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 6,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 7,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 8,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 9,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 10,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 11,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 12,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 13,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 14,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 15,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 16,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 17,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 18,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 19,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 20,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 21,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 22,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 23,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 24,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 25,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 26,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 27,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 28,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 29,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 30,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 31,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 32,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 33,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 34,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 35,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 36,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 37,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 38,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 39,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 40,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 41,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 42,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 43,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 44,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 45,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 46,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 47,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 48,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 49,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 50,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 51,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 52,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 53,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 54,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 55,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 56,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 57,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 58,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 59,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 60,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 61,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 62,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 63,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 64,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 65,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 66,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 67,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 68,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 69,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 70,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 71,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 72,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 73,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 74,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 75,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 76,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 77,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 78,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 79,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 80,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 81,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 82,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 83,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 84,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 85,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 86,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 87,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 88,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 89,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 90,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 91,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 92,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 93,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 94,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 95,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 96,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 97,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 98,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 99,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 100,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 101,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 102,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 103,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 104,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 105,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 106,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 107,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 108,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 109,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 110,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 111,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 112,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 113,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 114,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 115,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 116,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 117,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 118,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 119,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 120,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 121,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 122,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 123,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 124,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 125,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 126,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 127,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 128,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 129,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 130,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 131,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 132,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 133,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 134,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 135,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 136,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 137,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 138,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 139,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 140,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 141,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 142,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 143,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 144,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 145,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 146,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 147,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 148,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 149,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 150,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 151,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 152,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 153,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 154,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 155,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 156,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 157,
    "questionText": "A gaming application stores scores for players in an Amazon DynamoDB table that has four attributes: `user_id`, `user_name`, `user_score`, and `user_rank`. The users are allowed to update their names only if a user is authenticated by web identity federation. Which set of conditions should be added in the policy attached to the role for the `dynamodb:PutItem` API call?",
    "questionImage": null,
    "options": [
      {
        "text": "Option A.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Option B.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option C.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Option D.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 158,
    "questionText": "A Developer is working on an application that tracks hundreds of millions of product reviews in an Amazon DynamoDB table. The records include the data elements shown in the table. Which field, when used as the partition key, would result in the MOST consistent performance using DynamoDB?",
    "questionImage": null,
    "options": [
      {
        "text": "`starRating`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`reviewID`.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "`comment`.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "`productID`.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  },
  {
    "id": 159,
    "questionText": "The Lambda function below is being called through an API using Amazon API Gateway. The average execution time for the Lambda function is about 1 second. The pseudocode for the Lambda function is as shown in the exhibit. What two actions can be taken to improve the performance of this Lambda function without increasing the cost of the solution? (Select TWO)",
    "questionImage": null,
    "options": [
      {
        "text": "Package only the modules the Lambda function requires.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use Amazon DynamoDB instead of Amazon RDS.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Move the initialization of the variable Amazon RDS connection outside of the handler function.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Implement custom database connection pooling with the Lambda function.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Implement local caching of Amazon RDS data so Lambda can re-use the cache.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": true
  },
  {
    "id": 160,
    "questionText": "Given the source code for an AWS Lambda function in the local `store.py` containing a handler function called `get_store` and the following AWS CloudFormation template. What should be done to prepare the template so that it can be deployed using the AWS CLI command `aws cloudformation deploy`?",
    "questionImage": null,
    "options": [
      {
        "text": "Use AWS CloudFormation compile to base64 encode and embed the source file into a modified CloudFormation template.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS CloudFormation package to upload the source code to an Amazon S3 bucket and produce a modified CloudFormation template.",
        "image": null,
        "isCorrect": true
      },
      {
        "text": "Use AWS Lambda zip to package the source file together with the CloudFormation template and deploy the resulting zip archive.",
        "image": null,
        "isCorrect": false
      },
      {
        "text": "Use AWS Serverless `create-package` to embed the source file directly into the existing CloudFormation template.",
        "image": null,
        "isCorrect": false
      }
    ],
    "isMultipleChoice": false
  }
]